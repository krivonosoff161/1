"""
Trailing SL Coordinator ╨┤╨╗╤П Futures ╤В╨╛╤А╨│╨╛╨▓╨╗╨╕.

╨Ъ╨╛╨╛╤А╨┤╨╕╨╜╨╕╤А╤Г╨╡╤В ╤Г╨┐╤А╨░╨▓╨╗╨╡╨╜╨╕╨╡ Trailing Stop Loss ╨┤╨╗╤П ╨▓╤Б╨╡╤Е ╨┐╨╛╨╖╨╕╤Ж╨╕╨╣:
- ╨Ш╨╜╨╕╤Ж╨╕╨░╨╗╨╕╨╖╨░╤Ж╨╕╤П TSL ╨┤╨╗╤П ╨╜╨╛╨▓╤Л╤Е ╨┐╨╛╨╖╨╕╤Ж╨╕╨╣
- ╨Ю╨▒╨╜╨╛╨▓╨╗╨╡╨╜╨╕╨╡ TSL ╨┐╤А╨╕ ╨╕╨╖╨╝╨╡╨╜╨╡╨╜╨╕╨╕ ╤Ж╨╡╨╜╤Л
- ╨Я╨╡╤А╨╕╨╛╨┤╨╕╤З╨╡╤Б╨║╨░╤П ╨┐╤А╨╛╨▓╨╡╤А╨║╨░ TSL
- ╨Ю╨▒╤А╨░╨▒╨╛╤В╨║╨░ ╨╖╨░╨║╤А╤Л╤В╨╕╤П ╨┐╨╛╨╖╨╕╤Ж╨╕╨╣ ╨┐╨╛ TSL
- ╨Ш╨╜╤В╨╡╨│╤А╨░╤Ж╨╕╤П ╤Б DebugLogger
"""

import asyncio
import time
from datetime import datetime, timezone
from typing import Any, Awaitable, Callable, Dict, Optional

from loguru import logger

from ..indicators.trailing_stop_loss import TrailingStopLoss


class TrailingSLCoordinator:
    """
    ╨Ъ╨╛╨╛╤А╨┤╨╕╨╜╨░╤В╨╛╤А Trailing Stop Loss ╨┤╨╗╤П Futures ╤В╨╛╤А╨│╨╛╨▓╨╗╨╕.

    ╨г╨┐╤А╨░╨▓╨╗╤П╨╡╤В TSL ╨┤╨╗╤П ╨▓╤Б╨╡╤Е ╨┐╨╛╨╖╨╕╤Ж╨╕╨╣, ╨║╨╛╨╛╤А╨┤╨╕╨╜╨╕╤А╤Г╤П ╨▓╨╖╨░╨╕╨╝╨╛╨┤╨╡╨╣╤Б╤В╨▓╨╕╨╡ ╨╝╨╡╨╢╨┤╤Г
    TSL ╨╕╨╜╨┤╨╕╨║╨░╤В╨╛╤А╨╛╨╝, ╨║╨╛╨╜╤Д╨╕╨│╤Г╤А╨░╤Ж╨╕╨╡╨╣ ╨╕ ╨╗╨╛╨│╨╕╨║╨╛╨╣ ╨╖╨░╨║╤А╤Л╤В╨╕╤П ╨┐╨╛╨╖╨╕╤Ж╨╕╨╣.
    """

    def __init__(
        self,
        config_manager,
        debug_logger,
        signal_generator,
        client,
        scalping_config,
        get_position_callback: Callable[
            [str], Dict[str, Any]
        ],  # ╨б╨╕╨╜╤Е╤А╨╛╨╜╨╜╨░╤П ╤Д╤Г╨╜╨║╤Ж╨╕╤П ╨┤╨╗╤П ╨┐╨╛╨╗╤Г╤З╨╡╨╜╨╕╤П ╨┐╨╛╨╖╨╕╤Ж╨╕╨╕
        close_position_callback: Callable[
            [str, str], Awaitable[None]
        ],  # Async ╤Д╤Г╨╜╨║╤Ж╨╕╤П ╨┤╨╗╤П ╨╖╨░╨║╤А╤Л╤В╨╕╤П ╨┐╨╛╨╖╨╕╤Ж╨╕╨╕
        get_current_price_callback: Callable[
            [str], Awaitable[Optional[float]]
        ],  # Async ╤Д╤Г╨╜╨║╤Ж╨╕╤П ╨┤╨╗╤П ╨┐╨╛╨╗╤Г╤З╨╡╨╜╨╕╤П ╤Ж╨╡╨╜╤Л
        active_positions_ref: Optional[
            Dict[str, Dict[str, Any]]
        ] = None,  # ╨б╤Б╤Л╨╗╨║╨░ ╨╜╨░ active_positions (╨╛╨┐╤Ж╨╕╨╛╨╜╨░╨╗╤М╨╜╨╛)
        fast_adx=None,
        position_manager=None,
        order_flow=None,  # тЬЕ ╨н╨в╨Р╨Я 1.1: OrderFlowIndicator ╨┤╨╗╤П ╨░╨╜╨░╨╗╨╕╨╖╨░ ╤А╨░╨╖╨▓╨╛╤А╨╛╤В╨░
        exit_analyzer=None,  # тЬЕ ╨Э╨Ю╨Т╨Ю╨Х: ExitAnalyzer ╨┤╨╗╤П ╨░╨╜╨░╨╗╨╕╨╖╨░ ╨╖╨░╨║╤А╤Л╤В╨╕╤П
        position_registry=None,  # тЬЕ ╨Э╨Ю╨Т╨Ю╨Х (09.01.2026): PositionRegistry ╨┤╨╗╤П ╨┤╨╛╤Б╤В╤Г╨┐╨░ ╨║ DataRegistry
    ):
        """
        ╨Ш╨╜╨╕╤Ж╨╕╨░╨╗╨╕╨╖╨░╤Ж╨╕╤П TrailingSLCoordinator.

        Args:
            config_manager: ConfigManager ╨┤╨╗╤П ╨┐╨╛╨╗╤Г╤З╨╡╨╜╨╕╤П ╨┐╨░╤А╨░╨╝╨╡╤В╤А╨╛╨▓
            debug_logger: DebugLogger ╨┤╨╗╤П ╨╗╨╛╨│╨╕╤А╨╛╨▓╨░╨╜╨╕╤П
            signal_generator: SignalGenerator ╨┤╨╗╤П ╨┐╨╛╨╗╤Г╤З╨╡╨╜╨╕╤П ╤А╨╡╨╢╨╕╨╝╨░ ╤А╤Л╨╜╨║╨░
            client: Futures ╨║╨╗╨╕╨╡╨╜╤В ╨┤╨╗╤П ╨┐╨╛╨╗╤Г╤З╨╡╨╜╨╕╤П ╨┤╨░╨╜╨╜╤Л╤Е
            scalping_config: ╨Ъ╨╛╨╜╤Д╨╕╨│╤Г╤А╨░╤Ж╨╕╤П ╤Б╨║╨░╨╗╤М╨┐╨╕╨╜╨│╨░
            get_position_callback: ╨д╤Г╨╜╨║╤Ж╨╕╤П ╨┤╨╗╤П ╨┐╨╛╨╗╤Г╤З╨╡╨╜╨╕╤П ╨┐╨╛╨╖╨╕╤Ж╨╕╨╕ ╨┐╨╛ ╤Б╨╕╨╝╨▓╨╛╨╗╤Г
            close_position_callback: ╨д╤Г╨╜╨║╤Ж╨╕╤П ╨┤╨╗╤П ╨╖╨░╨║╤А╤Л╤В╨╕╤П ╨┐╨╛╨╖╨╕╤Ж╨╕╨╕
            get_current_price_callback: ╨д╤Г╨╜╨║╤Ж╨╕╤П ╨┤╨╗╤П ╨┐╨╛╨╗╤Г╤З╨╡╨╜╨╕╤П ╤В╨╡╨║╤Г╤Й╨╡╨╣ ╤Ж╨╡╨╜╤Л
            active_positions_ref: ╨б╤Б╤Л╨╗╨║╨░ ╨╜╨░ active_positions (╨╛╨┐╤Ж╨╕╨╛╨╜╨░╨╗╤М╨╜╨╛)
            fast_adx: FastADX ╨╕╨╜╨┤╨╕╨║╨░╤В╨╛╤А (╨╛╨┐╤Ж╨╕╨╛╨╜╨░╨╗╤М╨╜╨╛)
            position_manager: PositionManager ╨┤╨╗╤П profit harvesting (╨╛╨┐╤Ж╨╕╨╛╨╜╨░╨╗╤М╨╜╨╛)
            order_flow: OrderFlowIndicator ╨┤╨╗╤П ╨░╨╜╨░╨╗╨╕╨╖╨░ ╤А╨░╨╖╨▓╨╛╤А╨╛╤В╨░ (╨╛╨┐╤Ж╨╕╨╛╨╜╨░╨╗╤М╨╜╨╛)
            exit_analyzer: ExitAnalyzer ╨┤╨╗╤П ╨░╨╜╨░╨╗╨╕╨╖╨░ ╨╖╨░╨║╤А╤Л╤В╨╕╤П (╨╛╨┐╤Ж╨╕╨╛╨╜╨░╨╗╤М╨╜╨╛)
        """
        self.config_manager = config_manager  # ╨Ю╤Б╤В╨░╨▓╨╗╤П╨╡╨╝ ╨┤╨╗╤П ╨╛╨▒╤А╨░╤В╨╜╨╛╨╣ ╤Б╨╛╨▓╨╝╨╡╤Б╤В╨╕╨╝╨╛╤Б╤В╨╕
        self.parameter_provider = None  # тЬЕ ╨Э╨Ю╨Т╨Ю╨Х (26.12.2025): ParameterProvider ╨┤╨╗╤П ╨╡╨┤╨╕╨╜╨╛╨│╨╛ ╨┤╨╛╤Б╤В╤Г╨┐╨░ ╨║ ╨┐╨░╤А╨░╨╝╨╡╤В╤А╨░╨╝
        self.debug_logger = debug_logger
        self.signal_generator = signal_generator
        self.client = client
        self.scalping_config = scalping_config
        self.get_position_callback = get_position_callback
        self.close_position_callback = close_position_callback
        self.get_current_price_callback = get_current_price_callback
        self.active_positions_ref = (
            active_positions_ref  # ╨Ф╨╗╤П ╨┐╤А╤П╨╝╨╛╨│╨╛ ╨┤╨╛╤Б╤В╤Г╨┐╨░ ╨║ active_positions
        )
        self.fast_adx = fast_adx
        self.position_manager = position_manager
        self.order_flow = (
            order_flow  # тЬЕ ╨н╨в╨Р╨Я 1.1: OrderFlowIndicator ╨┤╨╗╤П ╨░╨╜╨░╨╗╨╕╨╖╨░ ╤А╨░╨╖╨▓╨╛╤А╨╛╤В╨░
        )
        self.exit_analyzer = (
            exit_analyzer  # тЬЕ ╨Э╨Ю╨Т╨Ю╨Х: ExitAnalyzer ╨┤╨╗╤П ╨░╨╜╨░╨╗╨╕╨╖╨░ ╨╖╨░╨║╤А╤Л╤В╨╕╤П (fallback)
        )
        self.position_registry = position_registry  # тЬЕ ╨Э╨Ю╨Т╨Ю╨Х (09.01.2026): PositionRegistry ╨┤╨╗╤П ╨┤╨╛╤Б╤В╤Г╨┐╨░ ╨║ DataRegistry
        self.exit_decision_coordinator = None  # тЬЕ ╨Э╨Ю╨Т╨Ю╨Х (26.12.2025): ExitDecisionCoordinator ╨┤╨╗╤П ╨║╨╛╨╛╤А╨┤╨╕╨╜╨░╤Ж╨╕╨╕ ╨╖╨░╨║╤А╤Л╤В╨╕╤П

        # тЬЕ ╨н╨в╨Р╨Я 1.1: ╨Ш╤Б╤В╨╛╤А╨╕╤П delta ╨┤╨╗╤П ╨░╨╜╨░╨╗╨╕╨╖╨░ ╤А╨░╨╖╨▓╨╛╤А╨╛╤В╨░ Order Flow
        self._order_flow_delta_history: Dict[
            str, list
        ] = {}  # symbol -> [(timestamp, delta), ...]

        # TSL ╨┤╨╗╤П ╨║╨░╨╢╨┤╨╛╨╣ ╨┐╨╛╨╖╨╕╤Ж╨╕╨╕
        self.trailing_sl_by_symbol: Dict[str, TrailingStopLoss] = {}

        # ╨Ъ╤Н╤И ╨┤╨╗╤П ╨┐╨╡╤А╨╕╨╛╨┤╨╕╤З╨╡╤Б╨║╨╛╨╣ ╨┐╤А╨╛╨▓╨╡╤А╨║╨╕
        self._last_tsl_check_time: Dict[str, float] = {}

        # ╨Ш╨╜╤В╨╡╤А╨▓╨░╨╗╤Л ╨┐╤А╨╛╨▓╨╡╤А╨║╨╕ TSL
        tsl_config = getattr(self.scalping_config, "trailing_sl", {})
        self._tsl_check_interval: float = getattr(
            tsl_config, "check_interval_seconds", 1.5
        )
        self._tsl_check_intervals_by_regime: Dict[str, float] = {}

        # ╨б╤З╨╡╤В╤З╨╕╨║ ╨╗╨╛╨│╨╛╨▓
        self._tsl_log_count: Dict[str, int] = {}

        logger.info("тЬЕ TrailingSLCoordinator initialized")

    def set_exit_decision_coordinator(self, exit_decision_coordinator):
        """
        тЬЕ ╨Э╨Ю╨Т╨Ю╨Х (26.12.2025): ╨г╤Б╤В╨░╨╜╨╛╨▓╨╕╤В╤М ExitDecisionCoordinator ╨┤╨╗╤П ╨║╨╛╨╛╤А╨┤╨╕╨╜╨░╤Ж╨╕╨╕ ╨╖╨░╨║╤А╤Л╤В╨╕╤П.

        Args:
            exit_decision_coordinator: ╨н╨║╨╖╨╡╨╝╨┐╨╗╤П╤А ExitDecisionCoordinator
        """
        self.exit_decision_coordinator = exit_decision_coordinator
        logger.debug("тЬЕ TrailingSLCoordinator: ExitDecisionCoordinator ╤Г╤Б╤В╨░╨╜╨╛╨▓╨╗╨╡╨╜")

    def set_parameter_provider(self, parameter_provider):
        """
        тЬЕ ╨Э╨Ю╨Т╨Ю╨Х (26.12.2025): ╨г╤Б╤В╨░╨╜╨╛╨▓╨╕╤В╤М ParameterProvider ╨┤╨╗╤П ╨╡╨┤╨╕╨╜╨╛╨│╨╛ ╨┤╨╛╤Б╤В╤Г╨┐╨░ ╨║ ╨┐╨░╤А╨░╨╝╨╡╤В╤А╨░╨╝.

        Args:
            parameter_provider: ╨н╨║╨╖╨╡╨╝╨┐╨╗╤П╤А ParameterProvider
        """
        self.parameter_provider = parameter_provider
        logger.debug("тЬЕ TrailingSLCoordinator: ParameterProvider ╤Г╤Б╤В╨░╨╜╨╛╨▓╨╗╨╡╨╜")

    async def on_regime_change(self, new_regime: str, symbol: Optional[str] = None):
        """
        тЬЕ FIX: ╨Я╨╡╤А╨╡╨╖╨░╨│╤А╤Г╨╖╨║╨░ ╨┐╨░╤А╨░╨╝╨╡╤В╤А╨╛╨▓ ╤В╤А╨╡╨╣╨╗╨╕╨╜╨│╨░ ╨┐╤А╨╕ ╤Б╨╝╨╡╨╜╨╡ ╤А╨╡╨╢╨╕╨╝╨░.

        Args:
            new_regime: ╨Э╨╛╨▓╤Л╨╣ ╤А╨╡╨╢╨╕╨╝ ╤А╤Л╨╜╨║╨░ (trending/ranging/choppy)
            symbol: ╨Ъ╨╛╨╜╨║╤А╨╡╤В╨╜╤Л╨╣ ╤Б╨╕╨╝╨▓╨╛╨╗ (╨╡╤Б╨╗╨╕ None тАФ ╨┤╨╗╤П ╨▓╤Б╨╡╤Е)
        """
        try:
            # тЬЕ ╨Э╨Ю╨Т╨Ю╨Х (26.12.2025): ╨Ш╤Б╨┐╨╛╨╗╤М╨╖╤Г╨╡╨╝ ParameterProvider ╨▓╨╝╨╡╤Б╤В╨╛ ╨┐╤А╤П╨╝╨╛╨│╨╛ ╨╛╨▒╤А╨░╤Й╨╡╨╜╨╕╤П ╨║ config_manager
            if self.parameter_provider:
                # ╨Ф╨╗╤П ╨╛╨▒╨╜╨╛╨▓╨╗╨╡╨╜╨╕╤П ╤А╨╡╨╢╨╕╨╝╨░ ╨╕╤Б╨┐╨╛╨╗╤М╨╖╤Г╨╡╨╝ config_manager ╨╜╨░╨┐╤А╤П╨╝╤Г╤О (╤В╨░╨║ ╨║╨░╨║ ╤А╨╡╨╢╨╕╨╝ ╨╝╨╡╨╜╤П╨╡╤В╤Б╤П ╨┤╨╗╤П ╨▓╤Б╨╡╤Е ╤Б╨╕╨╝╨▓╨╛╨╗╨╛╨▓)
                params = self.config_manager.get_trailing_sl_params(new_regime)
            else:
                params = self.config_manager.get_trailing_sl_params(new_regime)
            if not params:
                logger.warning(f"тЪая╕П ╨Э╨╡ ╨╜╨░╨╣╨┤╨╡╨╜╤Л TSL ╨┐╨░╤А╨░╨╝╨╡╤В╤А╤Л ╨┤╨╗╤П ╤А╨╡╨╢╨╕╨╝╨░ {new_regime}")
                return

            trail_distance_mult = params.get("trail_distance_multiplier", 1.0)
            trail_start_mult = params.get("trail_start_multiplier", 1.0)

            logger.info(
                f"TRAIL_RELOAD regime={new_regime} dist_mult={trail_distance_mult:.1f} start_mult={trail_start_mult:.1f}"
            )

            # ╨Ю╨▒╨╜╨╛╨▓╨╗╤П╨╡╨╝ ╨┐╨░╤А╨░╨╝╨╡╤В╤А╤Л ╨┤╨╗╤П ╨║╨╛╨╜╨║╤А╨╡╤В╨╜╨╛╨│╨╛ ╤Б╨╕╨╝╨▓╨╛╨╗╨░ ╨╕╨╗╨╕ ╨▓╤Б╨╡╤Е
            symbols_to_update = (
                [symbol] if symbol else list(self.trailing_sl_by_symbol.keys())
            )

            for sym in symbols_to_update:
                tsl = self.trailing_sl_by_symbol.get(sym)
                if tsl:
                    # ╨Ю╨▒╨╜╨╛╨▓╨╗╤П╨╡╨╝ multipliers ╨▓ TSL ╨╛╨▒╤К╨╡╨║╤В╨╡
                    if hasattr(tsl, "regime_multiplier"):
                        tsl.regime_multiplier = params.get("regime_multiplier", 1.0)
                    if hasattr(tsl, "high_profit_threshold"):
                        tsl.high_profit_threshold = params.get(
                            "high_profit_threshold", 0.01
                        )
                    if hasattr(tsl, "high_profit_max_factor"):
                        tsl.high_profit_max_factor = params.get(
                            "high_profit_max_factor", 2.0
                        )
                    logger.debug(f"тЬЕ TSL ╨┤╨╗╤П {sym} ╨╛╨▒╨╜╨╛╨▓╨╗╤С╨╜ ╨┐╨╛╨┤ ╤А╨╡╨╢╨╕╨╝ {new_regime}")
        except Exception as e:
            logger.error(f"тЭМ ╨Ю╤И╨╕╨▒╨║╨░ ╨┐╨╡╤А╨╡╨╖╨░╨│╤А╤Г╨╖╨║╨╕ TSL ╨┐╨░╤А╨░╨╝╨╡╤В╤А╨╛╨▓: {e}")

    def _get_position(self, symbol: str) -> Dict[str, Any]:
        """
        ╨Т╤Б╨┐╨╛╨╝╨╛╨│╨░╤В╨╡╨╗╤М╨╜╤Л╨╣ ╨╝╨╡╤В╨╛╨┤ ╨┤╨╗╤П ╨┐╨╛╨╗╤Г╤З╨╡╨╜╨╕╤П ╨┐╨╛╨╖╨╕╤Ж╨╕╨╕.

        ╨Ш╤Б╨┐╨╛╨╗╤М╨╖╤Г╨╡╤В active_positions_ref ╨╡╤Б╨╗╨╕ ╨┤╨╛╤Б╤В╤Г╨┐╨╜╨╛, ╨╕╨╜╨░╤З╨╡ get_position_callback.

        Args:
            symbol: ╨в╨╛╤А╨│╨╛╨▓╤Л╨╣ ╤Б╨╕╨╝╨▓╨╛╨╗

        Returns:
            ╨б╨╗╨╛╨▓╨░╤А╤М ╤Б ╨┤╨░╨╜╨╜╤Л╨╝╨╕ ╨┐╨╛╨╖╨╕╤Ж╨╕╨╕ ╨╕╨╗╨╕ ╨┐╤Г╤Б╤В╨╛╨╣ ╤Б╨╗╨╛╨▓╨░╤А╤М
        """
        if self.active_positions_ref is not None:
            return self.active_positions_ref.get(symbol, {})
        return self.get_position_callback(symbol) or {}

    def _has_position(self, symbol: str) -> bool:
        """
        ╨Т╤Б╨┐╨╛╨╝╨╛╨│╨░╤В╨╡╨╗╤М╨╜╤Л╨╣ ╨╝╨╡╤В╨╛╨┤ ╨┤╨╗╤П ╨┐╤А╨╛╨▓╨╡╤А╨║╨╕ ╨╜╨░╨╗╨╕╤З╨╕╤П ╨┐╨╛╨╖╨╕╤Ж╨╕╨╕.

        Args:
            symbol: ╨в╨╛╤А╨│╨╛╨▓╤Л╨╣ ╤Б╨╕╨╝╨▓╨╛╨╗

        Returns:
            True ╨╡╤Б╨╗╨╕ ╨┐╨╛╨╖╨╕╤Ж╨╕╤П ╤Б╤Г╤Й╨╡╤Б╤В╨▓╤Г╨╡╤В
        """
        if self.active_positions_ref is not None:
            return symbol in self.active_positions_ref
        position = self.get_position_callback(symbol)
        return position is not None and len(position) > 0

    def _get_trailing_sl_params(
        self, symbol: str, regime: Optional[str] = None
    ) -> Optional[Dict[str, Any]]:
        """
        ╨Я╨╛╨╗╤Г╤З╨░╨╡╤В ╨┐╨░╤А╨░╨╝╨╡╤В╤А╤Л Trailing SL ╨┤╨╗╤П ╤Б╨╕╨╝╨▓╨╛╨╗╨░ ╨╕ ╤А╨╡╨╢╨╕╨╝╨░.

        Args:
            symbol: ╨в╨╛╤А╨│╨╛╨▓╤Л╨╣ ╤Б╨╕╨╝╨▓╨╛╨╗
            regime: ╨а╨╡╨╢╨╕╨╝ ╤А╤Л╨╜╨║╨░ (trending/ranging/choppy)

        Returns:
            ╨б╨╗╨╛╨▓╨░╤А╤М ╤Б ╨┐╨░╤А╨░╨╝╨╡╤В╤А╨░╨╝╨╕ TSL ╨╕╨╗╨╕ None
        """
        try:
            # ╨Я╨╛╨╗╤Г╤З╨░╨╡╨╝ ╤А╨╡╨╢╨╕╨╝ ╨╡╤Б╨╗╨╕ ╨╜╨╡ ╤Г╨║╨░╨╖╨░╨╜
            if not regime:
                if hasattr(
                    self.signal_generator, "regime_managers"
                ) and symbol in getattr(self.signal_generator, "regime_managers", {}):
                    manager = self.signal_generator.regime_managers.get(symbol)
                    if manager:
                        regime = manager.get_current_regime()

            # тЬЕ ╨Э╨Ю╨Т╨Ю╨Х (26.12.2025): ╨Ш╤Б╨┐╨╛╨╗╤М╨╖╤Г╨╡╨╝ ParameterProvider ╨▓╨╝╨╡╤Б╤В╨╛ ╨┐╤А╤П╨╝╨╛╨│╨╛ ╨╛╨▒╤А╨░╤Й╨╡╨╜╨╕╤П ╨║ config_manager
            if self.parameter_provider:
                params = self.parameter_provider.get_trailing_sl_params(
                    symbol=symbol, regime=regime
                )
            else:
                # Fallback ╨╜╨░ config_manager
                params = self.config_manager.get_trailing_sl_params(regime=regime)
            return params
        except Exception as e:
            logger.debug(f"тЪая╕П ╨Ю╤И╨╕╨▒╨║╨░ ╨┐╨╛╨╗╤Г╤З╨╡╨╜╨╕╤П TSL ╨┐╨░╤А╨░╨╝╨╡╤В╤А╨╛╨▓ ╨┤╨╗╤П {symbol}: {e}")
            return None

    def initialize_trailing_stop(
        self,
        symbol: str,
        entry_price: float,
        side: str,
        current_price: Optional[float] = None,
        signal: Optional[Dict[str, Any]] = None,
    ) -> Optional[TrailingStopLoss]:
        """
        ╨б╨╛╨╖╨┤╨░╨╡╤В ╨╕╨╗╨╕ ╨┐╨╡╤А╨╡╨╕╨╜╨╕╤Ж╨╕╨░╨╗╨╕╨╖╨╕╤А╤Г╨╡╤В TrailingStopLoss ╨┤╨╗╤П ╤Г╨║╨░╨╖╨░╨╜╨╜╨╛╨│╨╛ ╤Б╨╕╨╝╨▓╨╛╨╗╨░.

        Args:
            symbol: ╨в╨╛╤А╨│╨╛╨▓╤Л╨╣ ╤Б╨╕╨╝╨▓╨╛╨╗
            entry_price: ╨ж╨╡╨╜╨░ ╨▓╤Е╨╛╨┤╨░
            side: ╨б╤В╨╛╤А╨╛╨╜╨░ ╨┐╨╛╨╖╨╕╤Ж╨╕╨╕ ("buy"/"sell" ╨╕╨╗╨╕ "long"/"short")
            current_price: ╨в╨╡╨║╤Г╤Й╨░╤П ╤Ж╨╡╨╜╨░ (╨╛╨┐╤Ж╨╕╨╛╨╜╨░╨╗╤М╨╜╨╛)
            signal: ╨б╨╕╨│╨╜╨░╨╗ ╤Б ╤А╨╡╨╢╨╕╨╝╨╛╨╝ ╤А╤Л╨╜╨║╨░ (╨╛╨┐╤Ж╨╕╨╛╨╜╨░╨╗╤М╨╜╨╛)

        Returns:
            TrailingStopLoss ╨╕╨╗╨╕ None ╨╡╤Б╨╗╨╕ ╨╜╨╡ ╤Г╨┤╨░╨╗╨╛╤Б╤М ╤Б╨╛╨╖╨┤╨░╤В╤М
        """
        if entry_price <= 0:
            return None

        # тЬЕ ╨н╨в╨Р╨Я 4.5: ╨Я╨╛╨╗╤Г╤З╨░╨╡╨╝ ╤А╨╡╨╢╨╕╨╝ ╤А╤Л╨╜╨║╨░ ╨┤╨╗╤П ╨░╨┤╨░╨┐╤В╨░╤Ж╨╕╨╕ ╨┐╨░╤А╨░╨╝╨╡╤В╤А╨╛╨▓
        regime = signal.get("regime") if signal else None
        if (
            not regime
            and hasattr(self.signal_generator, "regime_managers")
            and symbol in getattr(self.signal_generator, "regime_managers", {})
        ):
            manager = self.signal_generator.regime_managers.get(symbol)
            if manager:
                regime = manager.get_current_regime()

        # тЬЕ ╨н╨в╨Р╨Я 4: ╨Я╨╛╨╗╤Г╤З╨░╨╡╨╝ ╨┐╨░╤А╨░╨╝╨╡╤В╤А╤Л ╤Б ╨░╨┤╨░╨┐╤В╨░╤Ж╨╕╨╡╨╣ ╨┐╨╛╨┤ ╤А╨╡╨╢╨╕╨╝ ╤А╤Л╨╜╨║╨░
        # тЬЕ ╨Э╨Ю╨Т╨Ю╨Х (26.12.2025): ╨Ш╤Б╨┐╨╛╨╗╤М╨╖╤Г╨╡╨╝ ParameterProvider ╨▓╨╝╨╡╤Б╤В╨╛ ╨┐╤А╤П╨╝╨╛╨│╨╛ ╨╛╨▒╤А╨░╤Й╨╡╨╜╨╕╤П ╨║ config_manager
        if self.parameter_provider:
            params = self.parameter_provider.get_trailing_sl_params(
                symbol=symbol, regime=regime
            )
        else:
            # Fallback ╨╜╨░ config_manager
            params = self.config_manager.get_trailing_sl_params(regime=regime)

        # тЬЕ ╨Ш╨б╨Я╨а╨Р╨Т╨Ы╨Х╨Э╨Ш╨Х (09.01.2026): ╨Ы╨╛╨│╨╕╤А╨╛╨▓╨░╨╜╨╕╨╡ ╨┐╨░╤А╨░╨╝╨╡╤В╤А╨░ enabled ╨╕╨╖ ╨║╨╛╨╜╤Д╨╕╨│╨░
        tsl_config = getattr(self.scalping_config, "trailing_sl", {})
        tsl_enabled = getattr(tsl_config, "enabled", False)
        if isinstance(tsl_config, dict):
            tsl_enabled = tsl_config.get("enabled", False)

        logger.info(
            f"ЁЯФН TSL CONFIG CHECK ╨┤╨╗╤П {symbol}: "
            f"enabled={tsl_enabled} (╨╕╨╖ ╨║╨╛╨╜╤Д╨╕╨│╨░ trailing_sl.enabled), "
            f"regime={regime}, "
            f"loss_cut={params.get('loss_cut_percent')}, "
            f"min_holding={params.get('min_holding_minutes')} ╨╝╨╕╨╜, "
            f"timeout={params.get('timeout_minutes')} ╨╝╨╕╨╜"
        )

        # ╨Я╨╛╨╗╤Г╤З╨░╨╡╨╝ ╨┤╨╛╨┐╨╛╨╗╨╜╨╕╤В╨╡╨╗╤М╨╜╤Л╨╡ ╨┐╨╡╤А╨╡╨╛╨┐╤А╨╡╨┤╨╡╨╗╨╡╨╜╨╕╤П ╨╕╨╖ ╨┐╤А╨╛╤Д╨╕╨╗╤П ╤Б╨╕╨╝╨▓╨╛╨╗╨░ (╨╡╤Б╨╗╨╕ ╨╡╤Б╤В╤М)
        regime_profile = self.config_manager.get_symbol_regime_profile(symbol, regime)
        trailing_overrides = (
            self.config_manager.to_dict(regime_profile.get("trailing_sl", {}))
            if regime_profile
            else {}
        )
        if trailing_overrides:
            for key, value in trailing_overrides.items():
                if key in params and value is not None:
                    # тЬЕ ╨С╨╡╨╖╨╛╨┐╨░╤Б╨╜╨╛╨╡ ╨┐╤А╨╡╨╛╨▒╤А╨░╨╖╨╛╨▓╨░╨╜╨╕╨╡ ╤В╨╕╨┐╨╛╨▓
                    try:
                        if key == "extend_time_on_profit":
                            # Boolean ╨╖╨╜╨░╤З╨╡╨╜╨╕╨╡
                            if isinstance(value, str):
                                params[key] = value.lower() in (
                                    "true",
                                    "1",
                                    "yes",
                                    "on",
                                )
                            else:
                                params[key] = bool(value)
                        elif key in (
                            "min_holding_minutes",
                            "extend_time_multiplier",
                            "timeout_minutes",
                        ):
                            # Float ╨╖╨╜╨░╤З╨╡╨╜╨╕╤П ╨┤╨╗╤П ╨▓╤А╨╡╨╝╨╡╨╜╨╕
                            params[key] = float(value) if value is not None else None
                        else:
                            # ╨Ю╤Б╤В╨░╨╗╤М╨╜╤Л╨╡ ╤З╨╕╤Б╨╗╨╛╨▓╤Л╨╡ ╨╖╨╜╨░╤З╨╡╨╜╨╕╤П
                            params[key] = float(value)
                    except (TypeError, ValueError) as e:
                        logger.warning(
                            f"тЪая╕П ╨Э╨╡ ╤Г╨┤╨░╨╗╨╛╤Б╤М ╨┐╤А╨╡╨╛╨▒╤А╨░╨╖╨╛╨▓╨░╤В╤М {key}={value} ╨▓ ╨┐╤А╨░╨▓╨╕╨╗╤М╨╜╤Л╨╣ ╤В╨╕╨┐: {e}"
                        )
                        # ╨Ю╤Б╤В╨░╨▓╨╗╤П╨╡╨╝ ╨╖╨╜╨░╤З╨╡╨╜╨╕╨╡ ╨┐╨╛ ╤Г╨╝╨╛╨╗╤З╨░╨╜╨╕╤О
        # тЬЕ ╨У╨а╨Ю╨Ъ ╨д╨Ш╨Ъ╨б: TSL aggressive ╨┤╨╗╤П strong signals (strength > 0.8)
        # Trail 0.4% ╨┐╨╛╤Б╨╗╨╡ +0.6%, losscut 1.0% ╨┤╨╗╤П ╨▒╤Л╤Б╤В╤А╨╛╨╣ ╤Д╨╕╨║╤Б╨░╤Ж╨╕╨╕ ╨┐╤А╨╛╤Д╨╕╤В╨░
        signal_strength = signal.get("strength", 0.0) if signal else 0.0
        if signal_strength > 0.8:
            # ╨Р╨│╤А╨╡╤Б╤Б╨╕╨▓╨╜╤Л╨╣ TSL ╨┤╨╗╤П ╤Б╨╕╨╗╤М╨╜╤Л╤Е ╤Б╨╕╨│╨╜╨░╨╗╨╛╨▓
            params["initial_trail"] = 0.004  # 0.4% trail
            params["loss_cut_percent"] = 0.01  # 1.0% losscut
            logger.info(
                f"ЁЯЪА TSL AGGRESSIVE ╨┤╨╗╤П {symbol}: strength={signal_strength:.2f} > 0.8, "
                f"trail={params['initial_trail']:.2%}, losscut={params['loss_cut_percent']:.2%}"
            )

        impulse_trailing = None
        if signal and signal.get("is_impulse"):
            impulse_trailing = signal.get("impulse_trailing") or {}
            if impulse_trailing:
                params["initial_trail"] = impulse_trailing.get(
                    "initial_trail", params["initial_trail"]
                )

        # тЬЕ ╨Ъ╨а╨Ш╨в╨Ш╨з╨Х╨б╨Ъ╨Ю╨Х ╨Ш╨б╨Я╨а╨Р╨Т╨Ы╨Х╨Э╨Ш╨Х (02.01.2026): ╨Я╤А╨╛╨▓╨╡╤А╤П╨╡╨╝ ╤Б╤Г╤Й╨╡╤Б╤В╨▓╨╛╨▓╨░╨╜╨╕╨╡ TSL ╨┐╨╡╤А╨╡╨┤ ╨╕╨╜╨╕╤Ж╨╕╨░╨╗╨╕╨╖╨░╤Ж╨╕╨╡╨╣
        existing_tsl = self.trailing_sl_by_symbol.get(symbol)
        if existing_tsl:
            # тЬЕ ╨Ш╨б╨Я╨а╨Р╨Т╨Ы╨Х╨Э╨Ш╨Х: ╨Х╤Б╨╗╨╕ TSL ╤Г╨╢╨╡ ╤Б╤Г╤Й╨╡╤Б╤В╨▓╤Г╨╡╤В ╨╕ ╨┐╨░╤А╨░╨╝╨╡╤В╤А╤Л ╨╜╨╡ ╨╕╨╖╨╝╨╡╨╜╨╕╨╗╨╕╤Б╤М, ╨╜╨╡ ╨┐╨╡╤А╨╡╨╕╨╜╨╕╤Ж╨╕╨░╨╗╨╕╨╖╨╕╤А╤Г╨╡╨╝
            # ╨Я╤А╨╛╨▓╨╡╤А╤П╨╡╨╝, ╨╕╨╖╨╝╨╡╨╜╨╕╨╗╨╕╤Б╤М ╨╗╨╕ ╨║╤А╨╕╤В╨╕╤З╨╜╤Л╨╡ ╨┐╨░╤А╨░╨╝╨╡╤В╤А╤Л (trail, loss_cut)
            existing_trail = getattr(existing_tsl, "initial_trail", None)
            existing_loss_cut = getattr(existing_tsl, "loss_cut_percent", None)
            new_trail = params.get("initial_trail", 0.0)
            new_loss_cut = params.get("loss_cut_percent", 0.0)

            # ╨Х╤Б╨╗╨╕ ╨┐╨░╤А╨░╨╝╨╡╤В╤А╤Л ╨╜╨╡ ╨╕╨╖╨╝╨╡╨╜╨╕╨╗╨╕╤Б╤М ╨╕ entry_price ╤Б╨╛╨▓╨┐╨░╨┤╨░╨╡╤В, ╨╜╨╡ ╨┐╨╡╤А╨╡╨╕╨╜╨╕╤Ж╨╕╨░╨╗╨╕╨╖╨╕╤А╤Г╨╡╨╝
            if (
                existing_trail == new_trail
                and existing_loss_cut == new_loss_cut
                and abs(getattr(existing_tsl, "entry_price", 0) - entry_price) < 0.01
            ):
                logger.debug(
                    f"тД╣я╕П TSL ╨┤╨╗╤П {symbol} ╤Г╨╢╨╡ ╤Б╤Г╤Й╨╡╤Б╤В╨▓╤Г╨╡╤В ╤Б ╤В╨╡╨╝╨╕ ╨╢╨╡ ╨┐╨░╤А╨░╨╝╨╡╤В╤А╨░╨╝╨╕ "
                    f"(trail={new_trail:.2%}, loss_cut={new_loss_cut:.2%}, entry={entry_price:.2f}), "
                    f"╨┐╤А╨╛╨┐╤Г╤Б╨║╨░╨╡╨╝ ╨┐╨╛╨▓╤В╨╛╤А╨╜╤Г╤О ╨╕╨╜╨╕╤Ж╨╕╨░╨╗╨╕╨╖╨░╤Ж╨╕╤О"
                )
                return existing_tsl

            # ╨Я╨░╤А╨░╨╝╨╡╤В╤А╤Л ╨╕╨╖╨╝╨╡╨╜╨╕╨╗╨╕╤Б╤М ╨╕╨╗╨╕ entry_price ╨╛╤В╨╗╨╕╤З╨░╨╡╤В╤Б╤П - ╨┐╨╡╤А╨╡╨╕╨╜╨╕╤Ж╨╕╨░╨╗╨╕╨╖╨╕╤А╤Г╨╡╨╝
            logger.info(
                f"ЁЯФД TSL ╨┤╨╗╤П {symbol} ╨┐╨╡╤А╨╡╨╕╨╜╨╕╤Ж╨╕╨░╨╗╨╕╨╖╨╕╤А╤Г╨╡╤В╤Б╤П: "
                f"trail={existing_trail:.2%}тЖТ{new_trail:.2%}, "
                f"loss_cut={existing_loss_cut:.2%}тЖТ{new_loss_cut:.2%}, "
                f"entry={getattr(existing_tsl, 'entry_price', 0):.2f}тЖТ{entry_price:.2f}"
            )
            existing_tsl.reset()

        initial_trail = params["initial_trail"] or 0.0
        max_trail = params["max_trail"] or initial_trail
        min_trail = params["min_trail"] or 0.0
        trading_fee_rate = params["trading_fee_rate"] or 0.0

        # тЬЕ ╨н╨в╨Р╨Я 4: ╨б╨╛╨╖╨┤╨░╨╡╨╝ TrailingStopLoss ╤Б ╨╜╨╛╨▓╤Л╨╝╨╕ ╨┐╨░╤А╨░╨╝╨╡╤В╤А╨░╨╝╨╕
        # тЬЕ ╨Ъ╨а╨Ш╨в╨Ш╨з╨Х╨б╨Ъ╨Ю╨Х: ╨Я╨╛╨╗╤Г╤З╨░╨╡╨╝ leverage ╨╕╨╖ ╨║╨╛╨╜╤Д╨╕╨│╨░ ╨┤╨╗╤П ╨┐╤А╨░╨▓╨╕╨╗╤М╨╜╨╛╨│╨╛ ╤А╨░╤Б╤З╨╡╤В╨░ loss_cut ╨╛╤В ╨╝╨░╤А╨╢╨╕
        leverage = getattr(self.scalping_config, "leverage", 3)
        if leverage is None or leverage <= 0:
            leverage = 3
            logger.warning(
                f"тЪая╕П leverage ╨╜╨╡ ╤Г╨║╨░╨╖╨░╨╜ ╨▓ ╨║╨╛╨╜╤Д╨╕╨│╨╡ ╨┤╨╗╤П {symbol}, ╨╕╤Б╨┐╨╛╨╗╤М╨╖╤Г╨╡╨╝ 3 (fallback)"
            )

        tsl = TrailingStopLoss(
            initial_trail=initial_trail,
            max_trail=max_trail,
            min_trail=min_trail,
            trading_fee_rate=trading_fee_rate,
            loss_cut_percent=params["loss_cut_percent"],
            timeout_loss_percent=params["timeout_loss_percent"],
            timeout_minutes=params["timeout_minutes"],
            min_holding_minutes=params["min_holding_minutes"],  # тЬЕ ╨н╨в╨Р╨Я 4.4
            min_profit_to_close=params["min_profit_to_close"],  # тЬЕ ╨н╨в╨Р╨Я 4.1
            extend_time_on_profit=params["extend_time_on_profit"],  # тЬЕ ╨н╨в╨Р╨Я 4.3
            extend_time_multiplier=params["extend_time_multiplier"],  # тЬЕ ╨н╨в╨Р╨Я 4.3
            leverage=leverage,  # тЬЕ ╨Ъ╨а╨Ш╨в╨Ш╨з╨Х╨б╨Ъ╨Ю╨Х: ╨Я╨╡╤А╨╡╨┤╨░╨╡╨╝ leverage ╨┤╨╗╤П ╨┐╤А╨░╨▓╨╕╨╗╤М╨╜╨╛╨│╨╛ ╤А╨░╤Б╤З╨╡╤В╨░ loss_cut ╨╛╤В ╨╝╨░╤А╨╢╨╕
            min_critical_hold_seconds=params.get(
                "min_critical_hold_seconds"
            ),  # тЬЕ ╨Ъ╨а╨Ш╨в╨Ш╨з╨Х╨б╨Ъ╨Ю╨Х: ╨Ь╨╕╨╜╨╕╨╝╨░╨╗╤М╨╜╨╛╨╡ ╨▓╤А╨╡╨╝╤П ╨┤╨╗╤П ╨║╤А╨╕╤В╨╕╤З╨╡╤Б╨║╨╕╤Е ╤Г╨▒╤Л╤В╨║╨╛╨▓ (╨╕╨╖ ╨║╨╛╨╜╤Д╨╕╨│╨░)
            # тЬЕ ╨Э╨Ю╨Т╨Ю╨Х: ╨Я╨╡╤А╨╡╨┤╨░╨╡╨╝ trail_growth multipliers ╨┤╨╗╤П ╨░╨┤╨░╨┐╤В╨╕╨▓╨╜╨╛╨│╨╛ ╤В╤А╨╡╨╣╨╗╨╕╨╜╨│╨░
            trail_growth_low_multiplier=params.get("trail_growth_low_multiplier", 1.5),
            trail_growth_medium_multiplier=params.get(
                "trail_growth_medium_multiplier", 2.0
            ),
            trail_growth_high_multiplier=params.get(
                "trail_growth_high_multiplier", 3.0
            ),
            debug_logger=self.debug_logger,  # тЬЕ DEBUG LOGGER ╨┤╨╗╤П ╨╗╨╛╨│╨╕╤А╨╛╨▓╨░╨╜╨╕╤П
        )

        # тЬЕ ╨Р╨Ф╨Р╨Я╨в╨Ш╨Т╨Э╨Ю: ╨г╤Б╤В╨░╨╜╨░╨▓╨╗╨╕╨▓╨░╨╡╨╝ ╨┐╨░╤А╨░╨╝╨╡╤В╤А╤Л ╨╕╨╖ ╨║╨╛╨╜╤Д╨╕╨│╨░ ╨┤╨╗╤П TSL
        tsl.regime_multiplier = params.get("regime_multiplier", 1.0)
        tsl.trend_strength_boost = params.get("trend_strength_boost", 1.0)
        tsl.high_profit_threshold = params.get("high_profit_threshold", 0.01)
        tsl.high_profit_max_factor = params.get("high_profit_max_factor", 2.0)
        tsl.high_profit_reduction_percent = params.get(
            "high_profit_reduction_percent", 30
        )
        tsl.high_profit_min_reduction = params.get("high_profit_min_reduction", 0.5)

        # тЬЕ ╨Ъ╨а╨Ш╨в╨Ш╨з╨Х╨б╨Ъ╨Ю╨Х ╨Ш╨б╨Я╨а╨Р╨Т╨Ы╨Х╨Э╨Ш╨Х: ╨Ъ╨╛╨╜╨▓╨╡╤А╤В╨╕╤А╤Г╨╡╨╝ side ╨▓ position_side ("long"/"short")
        # side ╨╝╨╛╨╢╨╡╤В ╨▒╤Л╤В╤М "buy"/"sell" ╨╕╨╗╨╕ "long"/"short", ╨╜╨╛╤А╨╝╨░╨╗╨╕╨╖╤Г╨╡╨╝ ╨┤╨╛ "long"/"short"
        side_lower = side.lower()
        if side_lower in ["buy", "long"]:
            position_side = "long"
        elif side_lower in ["sell", "short"]:
            position_side = "short"
        else:
            logger.error(
                f"тЭМ ╨Э╨╡╨╕╨╖╨▓╨╡╤Б╤В╨╜╨░╤П ╤Б╤В╨╛╤А╨╛╨╜╨░ ╨┐╨╛╨╖╨╕╤Ж╨╕╨╕: {side} ╨┤╨╗╤П {symbol}. ╨Ш╤Б╨┐╨╛╨╗╤М╨╖╤Г╨╡╨╝ 'long' ╨┐╨╛ ╤Г╨╝╨╛╨╗╤З╨░╨╜╨╕╤О."
            )
            position_side = "long"

        # тЬЕ ╨Ъ╨а╨Ш╨в╨Ш╨з╨Х╨б╨Ъ╨Ю╨Х ╨Ш╨б╨Я╨а╨Р╨Т╨Ы╨Х╨Э╨Ш╨Х: ╨Я╨╛╨╗╤Г╤З╨░╨╡╨╝ entry_timestamp ╨╕╨╖ entry_time ╨┐╨╛╨╖╨╕╤Ж╨╕╨╕ ╨┤╨╗╤П ╨┐╤А╨░╨▓╨╕╨╗╤М╨╜╨╛╨╣ ╨╕╨╜╨╕╤Ж╨╕╨░╨╗╨╕╨╖╨░╤Ж╨╕╨╕ TSL
        entry_timestamp_for_tsl = None
        if signal and signal.get("entry_time"):
            entry_time_obj = signal.get("entry_time")
            if isinstance(entry_time_obj, datetime):
                entry_timestamp_for_tsl = entry_time_obj.timestamp()
            elif isinstance(entry_time_obj, (int, float)):
                # ╨Х╤Б╨╗╨╕ ╤Г╨╢╨╡ timestamp (╨▓ ╤Б╨╡╨║╤Г╨╜╨┤╨░╤Е ╨╕╨╗╨╕ ╨╝╨╕╨╗╨╗╨╕╤Б╨╡╨║╤Г╨╜╨┤╨░╤Е)
                if entry_time_obj > 1e10:  # ╨н╤В╨╛ ╨╝╨╕╨╗╨╗╨╕╤Б╨╡╨║╤Г╨╜╨┤╤Л
                    entry_timestamp_for_tsl = entry_time_obj / 1000.0
                else:  # ╨н╤В╨╛ ╤Б╨╡╨║╤Г╨╜╨┤╤Л
                    entry_timestamp_for_tsl = float(entry_time_obj)

        # тЬЕ ╨Э╨Ю╨Т╨Ю╨Х (03.01.2026): ╨Ы╨╛╨│╨╕╤А╨╛╨▓╨░╨╜╨╕╨╡ TP/SL ╨┐╨░╤А╨░╨╝╨╡╤В╤А╨╛╨▓ ╨┐╤А╨╕ ╨╛╤В╨║╤А╤Л╤В╨╕╨╕ ╨┐╨╛╨╖╨╕╤Ж╨╕╨╕
        try:
            if self.parameter_provider:
                # тЬЕ ╨Э╨Ю╨Т╨Ю╨Х (07.01.2026): ╨Я╨╡╤А╨╡╨┤╨░╨╡╨╝ ╨║╨╛╨╜╤В╨╡╨║╤Б╤В ╨┤╨╗╤П ╨░╨┤╨░╨┐╤В╨╕╨▓╨╜╤Л╤Е ╨┐╨░╤А╨░╨╝╨╡╤В╤А╨╛╨▓
                # тД╣я╕П ╨д╤Г╨╜╨║╤Ж╨╕╤П ╤Б╨╕╨╜╤Е╤А╨╛╨╜╨╜╨░, ╨┐╨╛╤Н╤В╨╛╨╝╤Г balance=None (╨░╨┤╨░╨┐╤В╨╕╨▓╨╜╤Л╨╡ ╨┐╨░╤А╨░╨╝╨╡╤В╤А╤Л ╨▒╤Г╨┤╤Г╤В ╨╕╤Б╨┐╨╛╨╗╤М╨╖╨╛╨▓╨░╨╜╤Л ╨▓ exit_analyzer)
                exit_params = self.parameter_provider.get_exit_params(
                    symbol=symbol, regime=regime, balance=None
                )
                if exit_params:
                    tp_atr_mult = exit_params.get("tp_atr_multiplier")
                    sl_atr_mult = exit_params.get("sl_atr_multiplier")
                    max_holding = exit_params.get("max_holding_minutes")
                    min_holding = exit_params.get("min_holding_minutes")

                    # ╨д╨╛╤А╨╝╨░╤В╨╕╤А╤Г╨╡╨╝ ╨╖╨╜╨░╤З╨╡╨╜╨╕╤П ╨┤╨╗╤П ╨╗╨╛╨│╨╕╤А╨╛╨▓╨░╨╜╨╕╤П
                    tp_atr_str = (
                        f"{tp_atr_mult:.2f}" if tp_atr_mult is not None else "N/A"
                    )
                    sl_atr_str = (
                        f"{sl_atr_mult:.2f}" if sl_atr_mult is not None else "N/A"
                    )
                    max_holding_str = (
                        f"{max_holding:.1f}" if max_holding is not None else "N/A"
                    )
                    min_holding_str = (
                        f"{min_holding:.1f}" if min_holding is not None else "N/A"
                    )

                    logger.info(
                        f"ЁЯУК [PARAMS] {symbol} ({regime or 'unknown'}): TP/SL ╨Я╨Р╨а╨Р╨Ь╨Х╨в╨а╨л ╨Я╨а╨Ш ╨Ю╨в╨Ъ╨а╨л╨в╨Ш╨Ш | "
                        f"tp_atr_multiplier={tp_atr_str}, sl_atr_multiplier={sl_atr_str}, "
                        f"max_holding={max_holding_str}╨╝╨╕╨╜, min_holding={min_holding_str}╨╝╨╕╨╜ | "
                        f"╨Ш╤Б╤В╨╛╤З╨╜╨╕╨║: ParameterProvider.get_exit_params()"
                    )
        except Exception as e:
            logger.debug(
                f"тЪая╕П ╨Ю╤И╨╕╨▒╨║╨░ ╨╗╨╛╨│╨╕╤А╨╛╨▓╨░╨╜╨╕╤П TP/SL ╨┐╨░╤А╨░╨╝╨╡╤В╤А╨╛╨▓ ╨┐╤А╨╕ ╨╛╤В╨║╤А╤Л╤В╨╕╨╕ ╨┤╨╗╤П {symbol}: {e}"
            )

        # тЬЕ ╨н╨в╨Р╨Я 4.4: ╨Ш╨╜╨╕╤Ж╨╕╨░╨╗╨╕╨╖╨╕╤А╤Г╨╡╨╝ ╤Б ╨┐╤А╨░╨▓╨╕╨╗╤М╨╜╨╛╨╣ ╤Б╤В╨╛╤А╨╛╨╜╨╛╨╣ (long/short) ╨╕ entry_timestamp
        tsl.initialize(
            entry_price=entry_price,
            side=position_side,
            symbol=symbol,
            entry_timestamp=entry_timestamp_for_tsl,  # тЬЕ ╨Ъ╨а╨Ш╨в╨Ш╨з╨Х╨б╨Ъ╨Ю╨Х: ╨Я╨╡╤А╨╡╨┤╨░╨╡╨╝ ╤А╨╡╨░╨╗╤М╨╜╨╛╨╡ ╨▓╤А╨╡╨╝╤П ╨╛╤В╨║╤А╤Л╤В╨╕╤П
        )
        if impulse_trailing:
            step_profit = float(impulse_trailing.get("step_profit", 0) or 0)
            step_trail = float(impulse_trailing.get("step_trail", 0) or 0)
            aggressive_cap = impulse_trailing.get("aggressive_max_trail")
            if step_profit > 0 and step_trail > 0:
                tsl.enable_aggressive_mode(
                    step_profit=step_profit,
                    step_trail=step_trail,
                    aggressive_max_trail=aggressive_cap,
                )
                logger.info(
                    f"ЁЯЪА TrailingSL ╨╕╨╝╨┐╤Г╨╗╤М╤Б╨╜╤Л╨╣ ╤А╨╡╨╢╨╕╨╝ ╨┤╨╗╤П {symbol}: step_profit={step_profit:.3%}, "
                    f"step_trail={step_trail:.3%}, cap={aggressive_cap if aggressive_cap else 'auto'}"
                )
        if current_price and current_price > 0:
            # тЬЕ ╨Ъ╨а╨Ш╨в╨Ш╨з╨Х╨б╨Ъ╨Ю╨Х ╨Ш╨б╨Я╨а╨Р╨Т╨Ы╨Х╨Э╨Ш╨Х: ╨Я╤А╨╕ ╨╕╨╜╨╕╤Ж╨╕╨░╨╗╨╕╨╖╨░╤Ж╨╕╨╕ margin/unrealized_pnl ╨╡╤Й╨╡ ╨╜╨╡╤В, ╨┐╨╡╤А╨╡╨┤╨░╨╡╨╝ None
            tsl.update(current_price, margin_used=None, unrealized_pnl=None)
        self.trailing_sl_by_symbol[symbol] = tsl
        fee_display = trading_fee_rate if trading_fee_rate else 0.0
        # тЬЕ ╨Ш╨б╨Я╨а╨Р╨Т╨Ы╨Х╨Э╨Ш╨Х: loss_cut_percent ╤Г╨╢╨╡ ╨▓ ╨┐╤А╨╛╤Ж╨╡╨╜╤В╨░╤Е (1.8 = 1.8%), ╨╜╨╡ ╨╜╤Г╨╢╨╜╨╛ ╤Г╨╝╨╜╨╛╨╢╨░╤В╤М ╨╜╨░ 100
        loss_cut_display = (
            params["loss_cut_percent"] if params["loss_cut_percent"] else 0.0
        )
        logger.info(
            f"тЬЕ TrailingStopLoss ╨┤╨╗╤П {symbol} ╨╕╨╜╨╕╤Ж╨╕╨░╨╗╨╕╨╖╨╕╤А╨╛╨▓╨░╨╜: "
            f"trail={tsl.current_trail:.3%}, fee={fee_display:.3%}, "
            f"loss_cut={loss_cut_display:.2f}% ╨╛╤В ╨╝╨░╤А╨╢╨╕, "
            f"min_holding={params['min_holding_minutes']:.1f} ╨╝╨╕╨╜, "
            f"regime={regime or 'N/A'}"
        )

        # тЬЕ DEBUG LOGGER: ╨Ы╨╛╨│╨╕╤А╤Г╨╡╨╝ ╤Б╨╛╨╖╨┤╨░╨╜╨╕╨╡ TSL
        if self.debug_logger:
            self.debug_logger.log_tsl_created(
                symbol=symbol,
                regime=regime or "unknown",
                entry_price=entry_price,
                side=position_side,
                min_holding=params.get("min_holding_minutes"),
                timeout=params.get("timeout_minutes"),
            )

        # тЬЕ DEBUG LOGGER: ╨Ы╨╛╨│╨╕╤А╤Г╨╡╨╝ ╨╖╨░╨│╤А╤Г╨╢╨╡╨╜╨╜╤Л╨╡ ╨┐╨░╤А╨░╨╝╨╡╤В╤А╤Л ╨║╨╛╨╜╤Д╨╕╨│╨░
        if self.debug_logger:
            self.debug_logger.log_config_loaded(
                symbol=symbol, regime=regime or "unknown", params=params
            )

        return tsl

    async def update_trailing_stop_loss(self, symbol: str, current_price: float):
        """╨Ю╨▒╨╜╨╛╨▓╨╗╨╡╨╜╨╕╨╡ TrailingStopLoss ╨┤╨╗╤П ╨╛╤В╨║╤А╤Л╤В╨╛╨╣ ╨┐╨╛╨╖╨╕╤Ж╨╕╨╕"""
        try:
            position = self._get_position(symbol)
            if not position:
                return

            entry_price = position.get("entry_price", 0)
            if isinstance(entry_price, str):
                try:
                    entry_price = float(entry_price)
                except (ValueError, TypeError):
                    entry_price = 0

            if entry_price == 0:
                avg_px = position.get("avgPx", 0)
                if isinstance(avg_px, str):
                    try:
                        avg_px = float(avg_px)
                    except (ValueError, TypeError):
                        avg_px = 0
                if avg_px and avg_px > 0:
                    entry_price = float(avg_px)
                    position["entry_price"] = entry_price
                    logger.info(
                        f"тЬЕ ╨Т╨╛╤Б╤Б╤В╨░╨╜╨╛╨▓╨╗╨╡╨╜ entry_price={entry_price:.2f} ╨┤╨╗╤П {symbol} ╨╕╨╖ avgPx"
                    )
                else:
                    try:
                        positions = await self.client.get_positions(symbol)
                        if positions:
                            for pos in positions:
                                pos_size = float(pos.get("pos", "0"))
                                if abs(pos_size) > 1e-8:
                                    api_avg_px_raw = pos.get("avgPx", "0")
                                    try:
                                        api_avg_px = float(api_avg_px_raw)
                                    except (ValueError, TypeError):
                                        api_avg_px = 0
                                    if api_avg_px and api_avg_px > 0:
                                        entry_price = api_avg_px
                                        position["entry_price"] = entry_price
                                        position["avgPx"] = entry_price
                                        logger.info(
                                            f"тЬЕ ╨Т╨╛╤Б╤Б╤В╨░╨╜╨╛╨▓╨╗╨╡╨╜ entry_price={entry_price:.2f} ╨┤╨╗╤П {symbol} ╤З╨╡╤А╨╡╨╖ API (╨┐╨╛╤Б╨╗╨╡ Partial TP)"
                                        )
                                        break
                    except Exception as e:
                        logger.debug(
                            f"тЪая╕П ╨Э╨╡ ╤Г╨┤╨░╨╗╨╛╤Б╤М ╨┐╨╛╨╗╤Г╤З╨╕╤В╤М entry_price ╨┤╨╗╤П {symbol} ╤З╨╡╤А╨╡╨╖ API: {e}"
                        )

                    if entry_price == 0:
                        # тЬЕ TODO #5: ╨Э╨╡ ╨▒╨╗╨╛╨║╨╕╤А╤Г╨╡╨╝ ╨┤╤А╤Г╨│╨╕╨╡ ╨┐╤А╨╛╨▓╨╡╤А╨║╨╕, ╨╡╤Б╨╗╨╕ entry_price == 0
                        logger.warning(
                            f"тЪая╕П Entry price = 0 ╨┤╨╗╤П {symbol}, avgPx={avg_px}, ╨╜╨╡ ╨╝╨╛╨╢╨╡╨╝ ╨╛╨▒╨╜╨╛╨▓╨╕╤В╤М TSL"
                        )
                        # тЬЕ ╨Я╤А╨╛╨▓╨╡╤А╤П╨╡╨╝, ╨╡╤Б╤В╤М ╨╗╨╕ ╨┐╨╛╨╖╨╕╤Ж╨╕╤П ╨▓╨╛╨╛╨▒╤Й╨╡
                        if not self._has_position(symbol):
                            return
                        # тЬЕ ╨Я╨╛╨╖╨╕╤Ж╨╕╤П ╤Б╤Г╤Й╨╡╤Б╤В╨▓╤Г╨╡╤В, ╨╜╨╛ entry_price=0 - ╤Н╤В╨╛ ╨┐╤А╨╛╨▒╨╗╨╡╨╝╨░, ╨╜╨╛ ╨╜╨╡ ╨║╤А╨╕╤В╨╕╤З╨╜╨╛ ╨┤╨╗╤П ╨┤╤А╤Г╨│╨╕╤Е ╨┐╤А╨╛╨▓╨╡╤А╨╛╨║
                        logger.debug(
                            f"тЪая╕П ╨Я╨╛╨╖╨╕╤Ж╨╕╤П {symbol} ╤Б╤Г╤Й╨╡╤Б╤В╨▓╤Г╨╡╤В, ╨╜╨╛ entry_price=0, ╨┐╤А╨╛╨┐╤Г╤Б╨║╨░╨╡╨╝ ╨╛╨▒╨╜╨╛╨▓╨╗╨╡╨╜╨╕╨╡ TSL "
                            f"(loss_cut ╨╝╨╛╨╢╨╡╤В ╨▒╤Л╤В╤М ╨┐╤А╨╛╨▓╨╡╤А╨╡╨╜ ╨▓ position_manager)"
                        )
                        return

            if symbol not in self.trailing_sl_by_symbol:
                logger.warning(
                    f"тЪая╕П TrailingStopLoss ╨╜╨╡ ╨╕╨╜╨╕╤Ж╨╕╨░╨╗╨╕╨╖╨╕╤А╨╛╨▓╨░╨╜ ╨┤╨╗╤П {symbol} "
                    f"(╨┐╨╛╨╖╨╕╤Ж╨╕╤П ╨╜╨░╨╣╨┤╨╡╨╜╨░ ╨▓ active_positions, ╨╜╨╛ ╨╜╨╡╤В ╨▓ trailing_sl_by_symbol). "
                    f"╨Ш╨╜╨╕╤Ж╨╕╨░╨╗╨╕╨╖╨╕╤А╤Г╨╡╨╝ TSL ╨░╨▓╤В╨╛╨╝╨░╤В╨╕╤З╨╡╤Б╨║╨╕..."
                )

                try:
                    pos_size = float(position.get("pos", position.get("size", "0")))
                    pos_side = position.get("posSide") or position.get(
                        "position_side", "long"
                    )

                    if entry_price <= 0:
                        avg_px = float(position.get("avgPx", "0") or 0)
                        if avg_px > 0:
                            entry_price = avg_px

                    if entry_price > 0 and abs(pos_size) > 0:
                        if "entry_time" not in position:
                            c_time = position.get("cTime")
                            u_time = position.get("uTime")
                            entry_time_str = c_time or u_time
                            if entry_time_str:
                                try:
                                    entry_timestamp = int(entry_time_str) / 1000
                                    # тЬЕ ╨Ш╨б╨Я╨а╨Р╨Т╨Ы╨Х╨Э╨Ю: ╨Ф╨╛╨▒╨░╨▓╨╗╤П╨╡╨╝ timezone.utc
                                    from datetime import timezone

                                    position["entry_time"] = datetime.fromtimestamp(
                                        entry_timestamp, tz=timezone.utc
                                    )
                                    position["timestamp"] = position["entry_time"]
                                    logger.debug(
                                        f"тЬЕ ╨г╤Б╤В╨░╨╜╨╛╨▓╨╗╨╡╨╜ entry_time ╨┤╨╗╤П {symbol} ╨╕╨╖ cTime/uTime: {position['entry_time']}"
                                    )
                                except (ValueError, TypeError) as e:
                                    logger.warning(
                                        f"тЪая╕П ╨Э╨╡ ╤Г╨┤╨░╨╗╨╛╤Б╤М ╤А╨░╤Б╨┐╨░╤А╤Б╨╕╤В╤М cTime/uTime ╨┤╨╗╤П {symbol}: {e}, ╨╕╤Б╨┐╨╛╨╗╤М╨╖╤Г╨╡╨╝ ╤В╨╡╨║╤Г╤Й╨╡╨╡ ╨▓╤А╨╡╨╝╤П"
                                    )
                                    from datetime import timezone

                                    position["entry_time"] = datetime.now(timezone.utc)
                                    position["timestamp"] = position["entry_time"]
                            else:
                                from datetime import timezone

                                position["entry_time"] = datetime.now(timezone.utc)
                                position["timestamp"] = position["entry_time"]
                                logger.debug(
                                    f"тЪая╕П entry_time ╨╜╨╡ ╨╜╨░╨╣╨┤╨╡╨╜ ╨┤╨╗╤П {symbol}, ╨╕╤Б╨┐╨╛╨╗╤М╨╖╤Г╨╡╨╝ ╤В╨╡╨║╤Г╤Й╨╡╨╡ ╨▓╤А╨╡╨╝╤П"
                                )

                        # тЬЕ ╨Ъ╨а╨Ш╨в╨Ш╨з╨Х╨б╨Ъ╨Ю╨Х: ╨Я╨╛╨╗╤Г╤З╨░╨╡╨╝ entry_time ╨╕╨╖ ╨┐╨╛╨╖╨╕╤Ж╨╕╨╕ ╨┤╨╗╤П ╨┐╨╡╤А╨╡╨┤╨░╤З╨╕ ╨▓ TSL
                        entry_time_from_pos = position.get("entry_time")
                        signal_with_entry_time = None
                        if entry_time_from_pos:
                            signal_with_entry_time = {"entry_time": entry_time_from_pos}

                        tsl = self.initialize_trailing_stop(
                            symbol=symbol,
                            entry_price=entry_price,
                            side=pos_side,
                            current_price=current_price,
                            signal=signal_with_entry_time,  # тЬЕ ╨Ъ╨а╨Ш╨в╨Ш╨з╨Х╨б╨Ъ╨Ю╨Х: ╨Я╨╡╤А╨╡╨┤╨░╨╡╨╝ entry_time
                        )

                        if tsl:
                            logger.info(
                                f"тЬЕ TrailingStopLoss ╨░╨▓╤В╨╛╨╝╨░╤В╨╕╤З╨╡╤Б╨║╨╕ ╨╕╨╜╨╕╤Ж╨╕╨░╨╗╨╕╨╖╨╕╤А╨╛╨▓╨░╨╜ ╨┤╨╗╤П {symbol} "
                                f"(entry={entry_price:.5f}, side={pos_side}, size={pos_size}, "
                                f"entry_time={position.get('entry_time', 'N/A')})"
                            )
                        else:
                            logger.error(
                                f"тЭМ ╨Э╨╡ ╤Г╨┤╨░╨╗╨╛╤Б╤М ╨╕╨╜╨╕╤Ж╨╕╨░╨╗╨╕╨╖╨╕╤А╨╛╨▓╨░╤В╤М TSL ╨┤╨╗╤П {symbol}"
                            )
                            return
                    else:
                        logger.warning(
                            f"тЪая╕П ╨Э╨╡╨┤╨╛╤Б╤В╨░╤В╨╛╤З╨╜╨╛ ╨┤╨░╨╜╨╜╤Л╤Е ╨┤╨╗╤П ╨╕╨╜╨╕╤Ж╨╕╨░╨╗╨╕╨╖╨░╤Ж╨╕╨╕ TSL ╨┤╨╗╤П {symbol}: "
                            f"entry_price={entry_price}, size={pos_size}"
                        )
                        return
                except Exception as e:
                    logger.error(
                        f"тЭМ ╨Ю╤И╨╕╨▒╨║╨░ ╨░╨▓╤В╨╛╨╝╨░╤В╨╕╤З╨╡╤Б╨║╨╛╨╣ ╨╕╨╜╨╕╤Ж╨╕╨░╨╗╨╕╨╖╨░╤Ж╨╕╨╕ TSL ╨┤╨╗╤П {symbol}: {e}"
                    )
                    return

                if symbol not in self.trailing_sl_by_symbol:
                    logger.error(
                        f"тЭМ TSL ╨┤╨╗╤П {symbol} ╨╜╨╡ ╨╕╨╜╨╕╤Ж╨╕╨░╨╗╨╕╨╖╨╕╤А╨╛╨▓╨░╨╜ ╨┐╨╛╤Б╨╗╨╡ ╨┐╨╛╨┐╤Л╤В╨║╨╕ ╨░╨▓╤В╨╛╨╝╨░╤В╨╕╤З╨╡╤Б╨║╨╛╨╣ ╨╕╨╜╨╕╤Ж╨╕╨░╨╗╨╕╨╖╨░╤Ж╨╕╨╕"
                    )
                    return

            tsl = self.trailing_sl_by_symbol[symbol]

            # тЬЕ ╨Ъ╨а╨Ш╨в╨Ш╨з╨Х╨б╨Ъ╨Ю╨Х ╨Ш╨б╨Я╨а╨Р╨Т╨Ы╨Х╨Э╨Ш╨Х: ╨Я╨╛╨╗╤Г╤З╨░╨╡╨╝ margin ╨╕ unrealizedPnl ╨Ф╨Ю ╨▓╤Л╨╖╨╛╨▓╨░ update()
            margin_used = None
            unrealized_pnl = None
            try:
                margin_str = position.get("margin") or position.get("imr") or "0"
                if margin_str and str(margin_str).strip() and str(margin_str) != "0":
                    margin_used = float(margin_str)
                upl_str = position.get("upl") or position.get("unrealizedPnl") or "0"
                if upl_str and str(upl_str).strip() and str(upl_str) != "0":
                    unrealized_pnl = float(upl_str)
            except (ValueError, TypeError) as e:
                logger.debug(
                    f"тЪая╕П TrailingSLCoordinator: ╨Ю╤И╨╕╨▒╨║╨░ ╨┐╨╛╨╗╤Г╤З╨╡╨╜╨╕╤П margin/upl ╨┤╨╗╤П {symbol}: {e}"
                )

            # тЬЕ FIX (09.01.2026): ╨Х╤Б╨╗╨╕ margin ╨╜╨╡ ╨╜╨░╨╣╨┤╨╡╨╜, ╤А╨░╤Б╤Б╤З╨╕╤В╤Л╨▓╨░╨╡╨╝ ╨╡╨│╨╛ ╨╕╨╖ size * entry_price / leverage
            if margin_used is None or margin_used <= 0:
                try:
                    pos_size = float(position.get("pos", "0") or 0)
                    leverage = float(
                        position.get("lever")
                        or getattr(self.scalping_config, "leverage", 5)
                        or 5
                    )
                    # ╨Я╨╛╨╗╤Г╤З╨░╨╡╨╝ ctVal ╨┤╨╗╤П ╤А╨░╤Б╤З╨╡╤В╨░ ╤Б╤В╨╛╨╕╨╝╨╛╤Б╤В╨╕ ╨┐╨╛╨╖╨╕╤Ж╨╕╨╕
                    ct_val = float(position.get("ctVal", "1") or 1)
                    position_value = abs(pos_size) * ct_val * entry_price
                    margin_used = (
                        position_value / leverage if leverage > 0 else position_value
                    )
                    logger.debug(
                        f"ЁЯУК TSL margin ╤А╨░╤Б╤З╨╕╤В╨░╨╜ ╨┤╨╗╤П {symbol}: size={pos_size}, entry=${entry_price:.2f}, "
                        f"lever={leverage}, margin=${margin_used:.2f}"
                    )
                except Exception as e:
                    logger.debug(f"тЪая╕П ╨Ю╤И╨╕╨▒╨║╨░ ╤А╨░╤Б╤З╨╡╤В╨░ margin ╨┤╨╗╤П {symbol}: {e}")

            # тЬЕ FIX (09.01.2026): ╨Х╤Б╨╗╨╕ unrealized_pnl ╨╜╨╡ ╨╜╨░╨╣╨┤╨╡╨╜, ╤А╨░╤Б╤Б╤З╨╕╤В╤Л╨▓╨░╨╡╨╝ ╨╡╨│╨╛
            if unrealized_pnl is None and entry_price > 0:
                try:
                    pos_size = float(position.get("pos", "0") or 0)
                    pos_side = position.get("posSide") or position.get(
                        "position_side", "long"
                    )
                    ct_val = float(position.get("ctVal", "1") or 1)
                    position_value = abs(pos_size) * ct_val
                    if pos_side.lower() == "long":
                        unrealized_pnl = position_value * (current_price - entry_price)
                    else:  # short
                        unrealized_pnl = position_value * (entry_price - current_price)
                    logger.debug(
                        f"ЁЯУК TSL unrealized_pnl ╤А╨░╤Б╤З╨╕╤В╨░╨╜ ╨┤╨╗╤П {symbol}: ${unrealized_pnl:.2f}"
                    )
                except Exception as e:
                    logger.debug(f"тЪая╕П ╨Ю╤И╨╕╨▒╨║╨░ ╤А╨░╤Б╤З╨╡╤В╨░ unrealized_pnl ╨┤╨╗╤П {symbol}: {e}")

            # тЬЕ ╨У╨а╨Ю╨Ъ ╨а╨Х╨Ъ╨Ю╨Ь╨Х╨Э╨Ф╨Р╨ж╨Ш╨п: ╨Я╤А╨╛╨▓╨╡╤А╨║╨░ min_profit_to_activate ╨┐╨╡╤А╨╡╨┤ ╨╛╨▒╨╜╨╛╨▓╨╗╨╡╨╜╨╕╨╡╨╝ trailing stop
            try:
                # ╨Я╨╛╨╗╤Г╤З╨░╨╡╨╝ ╨┐╨░╤А╨░╨╝╨╡╤В╤А╤Л trailing_sl ╨╕╨╖ ╨║╨╛╨╜╤Д╨╕╨│╨░
                trailing_sl_config = getattr(self.scalping_config, "trailing_sl", {})
                if isinstance(trailing_sl_config, dict):
                    min_profit_to_activate = trailing_sl_config.get(
                        "min_profit_to_activate", 0.008
                    )
                else:
                    min_profit_to_activate = getattr(
                        trailing_sl_config, "min_profit_to_activate", 0.008
                    )

                # ╨а╨░╤Б╤Б╤З╨╕╤В╤Л╨▓╨░╨╡╨╝ ╤В╨╡╨║╤Г╤Й╨╕╨╣ PnL%
                if entry_price > 0:
                    pos_side = position.get("posSide") or position.get(
                        "position_side", "long"
                    )
                    if pos_side.lower() == "long":
                        pnl_percent = (current_price - entry_price) / entry_price
                    else:  # short
                        pnl_percent = (entry_price - current_price) / entry_price

                    # ╨Х╤Б╨╗╨╕ ╨┐╤А╨╕╨▒╤Л╨╗╤М ╨╝╨╡╨╜╤М╤И╨╡ ╨╝╨╕╨╜╨╕╨╝╤Г╨╝╨░ - ╨╜╨╡ ╨╛╨▒╨╜╨╛╨▓╨╗╤П╨╡╨╝ trailing stop
                    if pnl_percent < min_profit_to_activate:
                        logger.debug(
                            f"тП╕я╕П Trailing SL ╨╜╨╡ ╨░╨║╤В╨╕╨▓╨╕╤А╨╛╨▓╨░╨╜ ╨┤╨╗╤П {symbol}: "
                            f"PnL {pnl_percent:.2%} < ╨╝╨╕╨╜╨╕╨╝╤Г╨╝ {min_profit_to_activate:.2%}"
                        )
                        return  # ╨Э╨╡ ╨╛╨▒╨╜╨╛╨▓╨╗╤П╨╡╨╝ trailing ╨┤╨╛ ╨┤╨╛╤Б╤В╨╕╨╢╨╡╨╜╨╕╤П ╨╝╨╕╨╜╨╕╨╝╤Г╨╝╨░
            except Exception as e:
                logger.debug(
                    f"тЪая╕П ╨Ю╤И╨╕╨▒╨║╨░ ╨┐╤А╨╛╨▓╨╡╤А╨║╨╕ min_profit_to_activate ╨┤╨╗╤П {symbol}: {e}, ╨┐╤А╨╛╨┤╨╛╨╗╨╢╨░╨╡╨╝ ╨╛╨▒╨╜╨╛╨▓╨╗╨╡╨╜╨╕╨╡"
                )
                # ╨Я╤А╨╛╨┤╨╛╨╗╨╢╨░╨╡╨╝ ╨╛╨▒╨╜╨╛╨▓╨╗╨╡╨╜╨╕╨╡ ╨┐╤А╨╕ ╨╛╤И╨╕╨▒╨║╨╡

            # тЬЕ ╨Ф╨Ш╨Э╨Р╨Ь╨Ш╨з╨Х╨б╨Ъ╨Ш╨Щ TSL: ╨Р╨┤╨░╨┐╤В╨░╤Ж╨╕╤П distance ╨╜╨░ ╨╛╤Б╨╜╨╛╨▓╨╡ ADX ╨╕ ╤А╨╡╨╢╨╕╨╝╨░
            tsl_mode = "normal"
            distance_multiplier = 1.0
            adx_value = None

            try:
                # ╨Я╨╛╨╗╤Г╤З╨░╨╡╨╝ ADX ╨┤╨╗╤П ╨░╨╜╨░╨╗╨╕╨╖╨░ ╤Б╨╕╨╗╤Л ╤В╤А╨╡╨╜╨┤╨░
                if self.fast_adx:
                    adx_value = self.fast_adx.get_current_adx()
                    if adx_value and adx_value > 0:
                        # Freeze ╤А╨╡╨╢╨╕╨╝: ADX > 35 (╤Б╨╕╨╗╤М╨╜╤Л╨╣ ╤В╤А╨╡╨╜╨┤) - ╤А╨░╤Б╤И╨╕╤А╤П╨╡╨╝ distance ╨╜╨░ 30-50%
                        if adx_value > 35:
                            tsl_mode = "freeze"
                            distance_multiplier = 1.4  # +40% ╨▓╨╛╨╖╨┤╤Г╤Е╨░ ╨┤╨╗╤П ╨╛╤В╨║╨░╤В╨╛╨▓
                            logger.debug(
                                f"ЁЯФ╡ [TSL_MODE] {symbol}: FREEZE ╤А╨╡╨╢╨╕╨╝ | ADX={adx_value:.1f} > 35 | "
                                f"distance_mult={distance_multiplier:.1f}x (╨┤╨░╤С╨╝ ╨▓╨╛╨╖╨┤╤Г╤Е ╨┤╨╗╤П ╨╛╤В╨║╨░╤В╨╛╨▓)"
                            )
                        # Tight ╤А╨╡╨╢╨╕╨╝: ADX < 25 (╤Б╨╗╨░╨▒╤Л╨╣/ranging) - ╤Г╨╢╨╡╤Б╤В╨╛╤З╨░╨╡╨╝ distance ╨╜╨░ 20-30%
                        elif adx_value < 25:
                            tsl_mode = "tight"
                            distance_multiplier = 0.75  # -25% ╨┤╨╗╤П ╨▒╤Л╤Б╤В╤А╨╛╨╣ ╤Д╨╕╨║╤Б╨░╤Ж╨╕╨╕
                            logger.debug(
                                f"ЁЯЯб [TSL_MODE] {symbol}: TIGHT ╤А╨╡╨╢╨╕╨╝ | ADX={adx_value:.1f} < 25 | "
                                f"distance_mult={distance_multiplier:.1f}x (╨╢╤С╤Б╤В╤З╨╡ ╤Д╨╕╨║╤Б╨╕╤А╤Г╨╡╨╝)"
                            )
                        # Normal ╤А╨╡╨╢╨╕╨╝: ADX 25-35 - ╤Б╤В╨░╨╜╨┤╨░╤А╤В╨╜╨░╤П ╨╗╨╛╨│╨╕╨║╨░
                        else:
                            logger.debug(
                                f"ЁЯЯв [TSL_MODE] {symbol}: NORMAL ╤А╨╡╨╢╨╕╨╝ | ADX={adx_value:.1f} [25-35]"
                            )
            except Exception as e:
                logger.debug(
                    f"тЪая╕П [TSL_MODE] ╨Ю╤И╨╕╨▒╨║╨░ ╨╛╨┐╤А╨╡╨┤╨╡╨╗╨╡╨╜╨╕╤П ╤А╨╡╨╢╨╕╨╝╨░ TSL ╨┤╨╗╤П {symbol}: {e}"
                )

            # тЬЕ ╨Ъ╨а╨Ш╨в╨Ш╨з╨Х╨б╨Ъ╨Ю╨Х ╨Ш╨б╨Я╨а╨Р╨Т╨Ы╨Х╨Э╨Ш╨Х: ╨Я╨╡╤А╨╡╨┤╨░╨╡╨╝ margin ╨╕ unrealizedPnl ╨▓ update() ╨┤╨╗╤П ╨┐╤А╨░╨▓╨╕╨╗╤М╨╜╨╛╨│╨╛ ╤А╨░╤Б╤З╨╡╤В╨░ ╨╛╤В ╨╝╨░╤А╨╢╨╕
            tsl.update(
                current_price,
                margin_used=margin_used if margin_used and margin_used > 0 else None,
                unrealized_pnl=unrealized_pnl if unrealized_pnl is not None else None,
            )

            stop_loss = tsl.get_stop_loss()

            # тЬЕ ╨Ф╨Ш╨Э╨Р╨Ь╨Ш╨з╨Х╨б╨Ъ╨Ш╨Щ TSL: ╨Я╤А╨╕╨╝╨╡╨╜╤П╨╡╨╝ distance_multiplier ╨║ stop_loss ╨╡╤Б╨╗╨╕ ╤А╨╡╨╢╨╕╨╝ ╨╜╨╡ normal
            if tsl_mode != "normal" and stop_loss and entry_price > 0:
                # ╨Я╨╛╨╗╤Г╤З╨░╨╡╨╝ pos_side ╨┤╨╗╤П ╨║╨╛╤А╤А╨╡╨║╤В╨╕╤А╨╛╨▓╨║╨╕ stop_loss
                pos_side = position.get("posSide") or position.get(
                    "position_side", "long"
                )
                # ╨а╨░╤Б╤Б╤З╨╕╤В╤Л╨▓╨░╨╡╨╝ ╤В╨╡╨║╤Г╤Й╤Г╤О distance
                current_distance = abs(stop_loss - entry_price) / entry_price
                # ╨Я╤А╨╕╨╝╨╡╨╜╤П╨╡╨╝ multiplier
                new_distance = current_distance * distance_multiplier
                # ╨Ъ╨╛╤А╤А╨╡╨║╤В╨╕╤А╤Г╨╡╨╝ stop_loss
                if pos_side.lower() == "long":
                    stop_loss = entry_price * (1 - new_distance)
                else:  # short
                    stop_loss = entry_price * (1 + new_distance)
                logger.debug(
                    f"ЁЯФз [TSL_ADJUST] {symbol}: distance {current_distance:.3%} тЖТ {new_distance:.3%}, "
                    f"stop_loss ╨║╨╛╤А╤А╨╡╨║╤В╨╕╤А╨╛╨▓╨░╨╜ ╨┐╨╛╨┤ {tsl_mode} ╤А╨╡╨╢╨╕╨╝"
                )

            profit_pct = tsl.get_profit_pct(
                current_price,
                include_fees=True,
                margin_used=margin_used if margin_used and margin_used > 0 else None,
                unrealized_pnl=unrealized_pnl if unrealized_pnl is not None else None,
            )
            profit_pct_gross = tsl.get_profit_pct(
                current_price,
                include_fees=False,
                margin_used=margin_used if margin_used and margin_used > 0 else None,
                unrealized_pnl=unrealized_pnl if unrealized_pnl is not None else None,
            )

            # тЬЕ FIX: TRAIL_DISTANCE_NARROW warning тАФ ╤Б╨╗╨╕╤И╨║╨╛╨╝ ╤Г╨╖╨║╨░╤П ╨┤╨╕╤Б╤В╨░╨╜╤Ж╨╕╤П
            if stop_loss and current_price > 0:
                distance_pct = abs(current_price - stop_loss) / current_price * 100
                if distance_pct < 0.05:
                    logger.warning(
                        f"TRAIL_DISTANCE_NARROW {symbol} {distance_pct:.2f}%"
                    )

            position_side = position.get(
                "position_side", position.get("posSide", "long")
            )
            if position_side.lower() == "short":
                extremum = tsl.lowest_price
                extremum_label = "lowest"
            else:
                extremum = tsl.highest_price
                extremum_label = "highest"

            # тЬЕ ╨н╨в╨Р╨Я 2.2: ╨г╨╗╤Г╤З╤И╨╡╨╜╨╜╤Л╨╣ ╨░╨╜╨░╨╗╨╕╨╖ ╤Б╨╕╨╗╤Л ╤В╤А╨╡╨╜╨┤╨░ (ADX + Order Flow + Multi-Timeframe)
            trend_strength = None
            market_regime = None
            trend_analysis = {
                "adx": None,
                "order_flow": None,
                "multi_timeframe": None,
                "combined": None,
            }

            try:
                # 1. ADX ╨░╨╜╨░╨╗╨╕╨╖
                if self.fast_adx:
                    adx_value = self.fast_adx.get_current_adx()
                    if adx_value and adx_value > 0:
                        trend_analysis["adx"] = min(adx_value / 100.0, 1.0)
                        trend_strength = trend_analysis["adx"]

                # 2. Order Flow ╨░╨╜╨░╨╗╨╕╨╖
                if self.order_flow:
                    try:
                        current_delta = self.order_flow.get_delta()
                        avg_delta = self.order_flow.get_avg_delta(periods=10)
                        delta_trend = self.order_flow.get_delta_trend()

                        # ╨Ю╨┐╤А╨╡╨┤╨╡╨╗╤П╨╡╨╝ ╤Б╨╕╨╗╤Г ╤В╤А╨╡╨╜╨┤╨░ ╨┐╨╛ Order Flow
                        if position_side.lower() == "long":
                            # ╨Ф╨╗╤П LONG: ╨┐╨╛╨╗╨╛╨╢╨╕╤В╨╡╨╗╤М╨╜╤Л╨╣ delta = ╤Б╨╕╨╗╤М╨╜╤Л╨╣ ╤В╤А╨╡╨╜╨┤
                            if current_delta > 0.1 and delta_trend == "long":
                                trend_analysis["order_flow"] = min(
                                    abs(current_delta) * 2, 1.0
                                )
                            elif current_delta > 0.05:
                                trend_analysis["order_flow"] = min(
                                    abs(current_delta) * 1.5, 0.7
                                )
                        elif position_side.lower() == "short":
                            # ╨Ф╨╗╤П SHORT: ╨╛╤В╤А╨╕╤Ж╨░╤В╨╡╨╗╤М╨╜╤Л╨╣ delta = ╤Б╨╕╨╗╤М╨╜╤Л╨╣ ╤В╤А╨╡╨╜╨┤
                            if current_delta < -0.1 and delta_trend == "short":
                                trend_analysis["order_flow"] = min(
                                    abs(current_delta) * 2, 1.0
                                )
                            elif current_delta < -0.05:
                                trend_analysis["order_flow"] = min(
                                    abs(current_delta) * 1.5, 0.7
                                )
                    except Exception as e:
                        logger.debug(f"тЪая╕П ╨Ю╤И╨╕╨▒╨║╨░ ╨░╨╜╨░╨╗╨╕╨╖╨░ Order Flow ╨┤╨╗╤П {symbol}: {e}")

                # 3. ╨Ъ╨╛╨╝╨▒╨╕╨╜╨╕╤А╨╛╨▓╨░╨╜╨╜╤Л╨╣ ╨░╨╜╨░╨╗╨╕╨╖ ╤Б╨╕╨╗╤Л ╤В╤А╨╡╨╜╨┤╨░
                if (
                    trend_analysis["adx"] is not None
                    or trend_analysis["order_flow"] is not None
                ):
                    # ╨Т╨╖╨▓╨╡╤И╨╡╨╜╨╜╨░╤П ╨║╨╛╨╝╨▒╨╕╨╜╨░╤Ж╨╕╤П: ADX 60%, Order Flow 40%
                    adx_weight = 0.6
                    of_weight = 0.4

                    adx_val = (
                        trend_analysis["adx"]
                        if trend_analysis["adx"] is not None
                        else 0.5
                    )
                    of_val = (
                        trend_analysis["order_flow"]
                        if trend_analysis["order_flow"] is not None
                        else 0.5
                    )

                    trend_analysis["combined"] = (adx_val * adx_weight) + (
                        of_val * of_weight
                    )
                    trend_strength = trend_analysis["combined"]

                    if self._tsl_log_count.get(symbol, 0) % 10 == 0:
                        # тЬЕ ╨Ъ╨а╨Ш╨в╨Ш╨з╨Х╨б╨Ъ╨Ю╨Х ╨Ш╨б╨Я╨а╨Р╨Т╨Ы╨Х╨Э╨Ш╨Х #6: ╨Ш╤Б╨┐╤А╨░╨▓╨╗╨╡╨╜╨╕╨╡ ╤Д╨╛╤А╨╝╨░╤В╨╕╤А╨╛╨▓╨░╨╜╨╕╤П f-string
                        adx_val = trend_analysis.get("adx")
                        adx_str = f"{adx_val:.2f}" if adx_val is not None else "N/A"
                        order_flow_val = trend_analysis.get("order_flow")
                        order_flow_str = (
                            f"{order_flow_val:.2f}"
                            if order_flow_val is not None
                            else "N/A"
                        )
                        logger.debug(
                            f"ЁЯУК ╨Р╨╜╨░╨╗╨╕╨╖ ╤Б╨╕╨╗╤Л ╤В╤А╨╡╨╜╨┤╨░ ╨┤╨╗╤П {symbol}: "
                            f"ADX={adx_str}, "
                            f"OrderFlow={order_flow_str}, "
                            f"Combined={trend_analysis['combined']:.2f}"
                        )
            except Exception as e:
                logger.debug(f"тЪая╕П ╨Э╨╡ ╤Г╨┤╨░╨╗╨╛╤Б╤М ╨┐╨╛╨╗╤Г╤З╨╕╤В╤М trend_strength ╨┤╨╗╤П {symbol}: {e}")

            try:
                if (
                    hasattr(self.signal_generator, "regime_manager")
                    and self.signal_generator.regime_manager
                ):
                    regime_obj = (
                        self.signal_generator.regime_manager.get_current_regime()
                    )
                    if regime_obj:
                        market_regime = (
                            regime_obj.lower() if isinstance(regime_obj, str) else None
                        )
            except Exception as e:
                logger.debug(f"╨Э╨╡ ╤Г╨┤╨░╨╗╨╛╤Б╤М ╨┐╨╛╨╗╤Г╤З╨╕╤В╤М market_regime: {e}")

            if symbol not in self._tsl_log_count:
                self._tsl_log_count[symbol] = 0
            self._tsl_log_count[symbol] += 1

            if self._tsl_log_count[symbol] % 5 == 0:
                trend_str = (
                    f"{trend_strength:.2f}" if trend_strength is not None else "N/A"
                )
                regime_str = market_regime or "N/A"
                adx_str = f"{adx_value:.1f}" if adx_value is not None else "N/A"
                distance_pct = (
                    abs(current_price - stop_loss) / current_price * 100
                    if stop_loss and current_price > 0
                    else 0.0
                )

                logger.info(
                    f"ЁЯФД [TSL_UPDATE] {symbol}: sl={stop_loss:.4f}, mode={tsl_mode}, "
                    f"ADX={adx_str}, distance={distance_pct:.2f}%, regime={regime_str} | "
                    f"price={current_price:.2f}, entry={entry_price:.2f}, "
                    f"{extremum_label}={extremum:.2f}, profit={profit_pct:.2%} (net), "
                    f"gross={profit_pct_gross:.2%}, trend={trend_str}"
                )

            if not self._has_position(symbol):
                logger.debug(
                    f"тЪая╕П ╨Я╨╛╨╖╨╕╤Ж╨╕╤П {symbol} ╤Г╨╢╨╡ ╨╖╨░╨║╤А╤Л╤В╨░ ╨╕╨╗╨╕ ╨╖╨░╨║╤А╤Л╨▓╨░╨╡╤В╤Б╤П, ╨┐╤А╨╛╨┐╤Г╤Б╨║╨░╨╡╨╝ ╨┐╤А╨╛╨▓╨╡╤А╨║╤Г TSL"
                )
                return

            # тЬЕ ╨Э╨Ю╨Т╨Ю╨Х (26.12.2025): ╨Ш╤Б╨┐╨╛╨╗╤М╨╖╤Г╨╡╨╝ ExitDecisionCoordinator ╨┤╨╗╤П ╨║╨╛╨╛╤А╨┤╨╕╨╜╨░╤Ж╨╕╨╕ ╨╖╨░╨║╤А╤Л╤В╨╕╤П
            exit_decision = None
            if self.exit_decision_coordinator:
                try:
                    # ╨Я╨╛╨╗╤Г╤З╨░╨╡╨╝ ╨┐╨╛╨╖╨╕╤Ж╨╕╤О ╨╕ ╨╝╨╡╤В╨░╨┤╨░╨╜╨╜╤Л╨╡ ╨┤╨╗╤П ╨║╨╛╨╛╤А╨┤╨╕╨╜╨░╤В╨╛╤А╨░
                    position = self.get_position_callback(symbol)
                    metadata = None
                    if hasattr(self, "position_registry") and self.position_registry:
                        try:
                            metadata = await self.position_registry.get_metadata(symbol)
                        except Exception:
                            pass

                    # тЬЕ ╨Ш╨б╨Я╨а╨Р╨Т╨Ы╨Х╨Э╨Ш╨Х (09.01.2026): ╨Ф╨╛╨▒╨░╨▓╨╗╨╡╨╜ price=0 guardrail ╤Б retry
                    current_price = await self.get_current_price_callback(symbol)
                    if current_price is None or current_price == 0:
                        logger.warning(
                            f"тЪая╕П {symbol}: ╨Я╨╛╨╗╤Г╤З╨╡╨╜╨░ ╨╜╨╡╨║╨╛╤А╤А╨╡╨║╤В╨╜╨░╤П ╤Ж╨╡╨╜╨░ (price={current_price}), "
                            f"╨┐╤Л╤В╨░╨╡╨╝╤Б╤П ╨┐╨╛╨▓╤В╨╛╤А╨╜╨╛ ╤З╨╡╤А╨╡╨╖ 1 ╤Б╨╡╨║..."
                        )
                        await asyncio.sleep(1)
                        current_price = await self.get_current_price_callback(symbol)

                        if current_price is None or current_price == 0:
                            # ╨Х╤Б╨╗╨╕ ╤Б╨╜╨╛╨▓╨░ price=0, ╨╕╤Б╨┐╨╛╨╗╤М╨╖╤Г╨╡╨╝ entry_price ╨║╨░╨║ fallback
                            if (
                                position
                                and hasattr(position, "entry_price")
                                and position.entry_price > 0
                            ):
                                logger.error(
                                    f"тЭМ {symbol}: ╨Я╨╛╨╗╤Г╤З╨╡╨╜╨░ ╨╜╨╡╨║╨╛╤А╤А╨╡╨║╤В╨╜╨░╤П ╤Ж╨╡╨╜╨░ ╨┐╨╛╤Б╨╗╨╡ ╨┐╨╛╨▓╤В╨╛╤А╨╜╨╛╨╣ ╨┐╨╛╨┐╤Л╤В╨║╨╕ "
                                    f"(price={current_price}), ╨╕╤Б╨┐╨╛╨╗╤М╨╖╤Г╨╡╨╝ entry_price={position.entry_price} ╨║╨░╨║ fallback"
                                )
                                current_price = position.entry_price
                            else:
                                logger.error(
                                    f"тЭМ {symbol}: ╨Ъ╤А╨╕╤В╨╕╤З╨╡╤Б╨║╨░╤П ╨╛╤И╨╕╨▒╨║╨░ - ╨╜╨╡ ╤Г╨┤╨░╨╗╨╛╤Б╤М ╨┐╨╛╨╗╤Г╤З╨╕╤В╤М ╨▓╨░╨╗╨╕╨┤╨╜╤Г╤О ╤Ж╨╡╨╜╤Г "
                                    f"(price={current_price}, entry_price ╨╜╨╡╨┤╨╛╤Б╤В╤Г╨┐╨╡╨╜), ╨┐╤А╨╛╨┐╤Г╤Б╨║╨░╨╡╨╝ ╨┐╤А╨╛╨▓╨╡╤А╨║╤Г TSL"
                                )
                                current_price = 0.0

                    # ╨Я╨╛╨╗╤Г╤З╨░╨╡╨╝ ╤А╨╡╨╢╨╕╨╝
                    regime = "ranging"
                    if self.signal_generator and hasattr(
                        self.signal_generator, "regime_managers"
                    ):
                        regime_manager = self.signal_generator.regime_managers.get(
                            symbol
                        )
                        if regime_manager:
                            regime = regime_manager.get_current_regime() or "ranging"

                    exit_decision = (
                        await self.exit_decision_coordinator.analyze_position(
                            symbol=symbol,
                            position=position,
                            metadata=metadata,
                            market_data=None,
                            current_price=current_price,
                            regime=regime,
                        )
                    )
                except Exception as e:
                    logger.debug(
                        f"тЪая╕П TrailingSLCoordinator: ╨Ю╤И╨╕╨▒╨║╨░ ╨▓╤Л╨╖╨╛╨▓╨░ ExitDecisionCoordinator ╨┤╨╗╤П {symbol}: {e}"
                    )
            elif self.exit_analyzer:
                # Fallback: ╨╕╤Б╨┐╨╛╨╗╤М╨╖╤Г╨╡╨╝ ExitAnalyzer ╨╜╨░╨┐╤А╤П╨╝╤Г╤О
                try:
                    exit_decision = await self.exit_analyzer.analyze_position(symbol)
                    if exit_decision:
                        action = exit_decision.get("action")
                        reason = exit_decision.get("reason", "exit_analyzer")
                        # тЬЕ ╨Ш╨б╨Я╨а╨Р╨Т╨Ы╨Х╨Э╨Ш╨Х: pnl_pct ╨╕╨╖ ExitAnalyzer ╨▓ ╨┐╤А╨╛╤Ж╨╡╨╜╤В╨░╤Е (0.5 = 0.5%)
                        # _calculate_pnl_percent ╨▓╨╛╨╖╨▓╤А╨░╤Й╨░╨╡╤В ╨┐╤А╨╛╤Ж╨╡╨╜╤В╤Л (0.5 = 0.5%)
                        # profit_pct ╨╕╨╖ TSL ╨▓ ╨┤╨╛╨╗╤П╤Е (0.005 = 0.5%), ╨║╨╛╨╜╨▓╨╡╤А╤В╨╕╤А╤Г╨╡╨╝ ╨┤╨╗╤П ╨╡╨┤╨╕╨╜╨╛╨╛╨▒╤А╨░╨╖╨╕╤П
                        decision_pnl_raw = exit_decision.get("pnl_pct")
                        if decision_pnl_raw is not None:
                            # pnl_pct ╨╕╨╖ ExitAnalyzer ╨▓ ╨┐╤А╨╛╤Ж╨╡╨╜╤В╨░╤Е (0.5 = 0.5%) -> ╨▓ ╨┤╨╛╨╗╤О ╨┤╨╗╤П ╨╡╨┤╨╕╨╜╨╛╨│╨╛ ╤Д╨╛╤А╨╝╨░╤В╨╕╤А╨╛╨▓╨░╨╜╨╕╤П
                            decision_pnl_frac = float(decision_pnl_raw) / 100.0
                        else:
                            # Fallback: profit_pct ╨╕╨╖ TSL ╤Г╨╢╨╡ ╨▓ ╨┤╨╛╨╗╤П╤Е
                            decision_pnl_frac = float(profit_pct or 0.0)

                        logger.info(
                            f"ЁЯОп ExitAnalyzer ╤А╨╡╤И╨╡╨╜╨╕╨╡ ╨┤╨╗╤П {symbol}: action={action}, "
                            f"reason={reason}, pnl={decision_pnl_frac:.2%}"
                        )

                        # ╨Х╤Б╨╗╨╕ ExitAnalyzer ╤А╨╡╤И╨╕╨╗ ╨╖╨░╨║╤А╤Л╤В╤М - ╨╖╨░╨║╤А╤Л╨▓╨░╨╡╨╝ ╤Б╤А╨░╨╖╤Г
                        if action == "close":
                            logger.info(
                                f"тЬЕ ExitAnalyzer: ╨Ч╨░╨║╤А╤Л╨▓╨░╨╡╨╝ {symbol} (reason={reason}, pnl={decision_pnl_frac:.2%})"
                            )
                            if self._has_position(symbol):
                                await self.close_position_callback(symbol, reason)
                            return
                        # тЬЕ ╨Х╤Б╨╗╨╕ ExitAnalyzer ╤А╨╡╤И╨╕╨╗ ╤З╨░╤Б╤В╨╕╤З╨╜╨╛ ╨╖╨░╨║╤А╤Л╤В╤М - ╨▓╤Л╨┐╨╛╨╗╨╜╤П╨╡╨╝ ╤З╨░╤Б╤В╨╕╤З╨╜╨╛╨╡ ╨╖╨░╨║╤А╤Л╤В╨╕╨╡
                        elif action == "partial_close":
                            fraction = exit_decision.get("fraction", 0.5)
                            logger.info(
                                f"ЁЯУК ExitAnalyzer: ╨з╨░╤Б╤В╨╕╤З╨╜╨╛╨╡ ╨╖╨░╨║╤А╤Л╤В╨╕╨╡ {symbol} ({fraction*100:.0f}%, reason={reason})"
                            )

                            # ╨Т╤Л╨┐╨╛╨╗╨╜╤П╨╡╨╝ ╤З╨░╤Б╤В╨╕╤З╨╜╨╛╨╡ ╨╖╨░╨║╤А╤Л╤В╨╕╨╡ ╤З╨╡╤А╨╡╨╖ position_manager
                            if self.position_manager and hasattr(
                                self.position_manager, "close_partial_position"
                            ):
                                try:
                                    partial_result = await self.position_manager.close_partial_position(
                                        symbol=symbol,
                                        fraction=fraction,
                                        reason=reason,
                                    )

                                    if partial_result and partial_result.get("success"):
                                        logger.info(
                                            f"тЬЕ ╨з╨░╤Б╤В╨╕╤З╨╜╨╛╨╡ ╨╖╨░╨║╤А╤Л╤В╨╕╨╡ {symbol} ╨▓╤Л╨┐╨╛╨╗╨╜╨╡╨╜╨╛: "
                                            f"╨╖╨░╨║╤А╤Л╤В╨╛ {fraction*100:.0f}%, "
                                            f"PnL={partial_result.get('net_partial_pnl', 0):+.2f} USDT"
                                        )
                                        # ╨Я╨╛╤Б╨╗╨╡ ╤З╨░╤Б╤В╨╕╤З╨╜╨╛╨│╨╛ ╨╖╨░╨║╤А╤Л╤В╨╕╤П ╨┐╤А╨╛╨┤╨╛╨╗╨╢╨░╨╡╨╝ ╨╝╨╛╨╜╨╕╤В╨╛╤А╨╕╨╜╨│ ╨╛╤Б╤В╨░╨▓╤И╨╡╨╣╤Б╤П ╨┐╨╛╨╖╨╕╤Ж╨╕╨╕
                                    else:
                                        logger.warning(
                                            f"тЪая╕П ╨Э╨╡ ╤Г╨┤╨░╨╗╨╛╤Б╤М ╨▓╤Л╨┐╨╛╨╗╨╜╨╕╤В╤М ╤З╨░╤Б╤В╨╕╤З╨╜╨╛╨╡ ╨╖╨░╨║╤А╤Л╤В╨╕╨╡ {symbol}: "
                                            f"{partial_result.get('error', '╨╜╨╡╨╕╨╖╨▓╨╡╤Б╤В╨╜╨░╤П ╨╛╤И╨╕╨▒╨║╨░')}"
                                        )
                                except Exception as e:
                                    logger.error(
                                        f"тЭМ ╨Ю╤И╨╕╨▒╨║╨░ ╨┐╤А╨╕ ╤З╨░╤Б╤В╨╕╤З╨╜╨╛╨╝ ╨╖╨░╨║╤А╤Л╤В╨╕╨╕ {symbol}: {e}",
                                        exc_info=True,
                                    )
                            else:
                                logger.warning(
                                    f"тЪая╕П PositionManager ╨╜╨╡ ╨┤╨╛╤Б╤В╤Г╨┐╨╡╨╜ ╨┤╨╗╤П ╤З╨░╤Б╤В╨╕╤З╨╜╨╛╨│╨╛ ╨╖╨░╨║╤А╤Л╤В╨╕╤П {symbol}"
                                )

                        # тЬЕ ╨Х╤Б╨╗╨╕ ExitAnalyzer ╤А╨╡╤И╨╕╨╗ ╨┐╤А╨╛╨┤╨╗╨╕╤В╤М TP - ╨╛╨▒╨╜╨╛╨▓╨╗╤П╨╡╨╝ ╨┐╨░╤А╨░╨╝╨╡╤В╤А╤Л TSL
                        elif action == "extend_tp":
                            new_tp_percent = exit_decision.get("new_tp")
                            trend_strength_extend = exit_decision.get(
                                "trend_strength", 0.0
                            )

                            logger.info(
                                f"ЁЯУИ ExitAnalyzer: ╨Я╤А╨╛╨┤╨╗╨╡╨▓╨░╨╡╨╝ TP ╨┤╨╗╤П {symbol} "
                                f"(╨╜╨╛╨▓╤Л╨╣ TP={new_tp_percent:.2f}%, trend_strength={trend_strength_extend:.2f}, reason={reason})"
                            )

                            # ╨Ю╨▒╨╜╨╛╨▓╨╗╤П╨╡╨╝ ╨┐╨░╤А╨░╨╝╨╡╤В╤А╤Л TSL ╨┤╨╗╤П ╨┐╤А╨╛╨┤╨╗╨╡╨╜╨╕╤П TP
                            if symbol in self.trailing_sl_by_symbol:
                                tsl = self.trailing_sl_by_symbol[symbol]

                                # ╨б╨╛╤Е╤А╨░╨╜╤П╨╡╨╝ ╨╛╤А╨╕╨│╨╕╨╜╨░╨╗╤М╨╜╤Л╨╣ TP ╨┤╨╗╤П ╨╛╤В╤Б╨╗╨╡╨╢╨╕╨▓╨░╨╜╨╕╤П ╨┐╤А╨╛╨┤╨╗╨╡╨╜╨╕╤П
                                if not hasattr(tsl, "original_tp_percent"):
                                    # ╨Я╨╛╨╗╤Г╤З╨░╨╡╨╝ ╨╛╤А╨╕╨│╨╕╨╜╨░╨╗╤М╨╜╤Л╨╣ TP ╨╕╨╖ ╨║╨╛╨╜╤Д╨╕╨│╨░ ╨╕╨╗╨╕ ╨╝╨╡╤В╨░╨┤╨░╨╜╨╜╤Л╤Е
                                    original_tp = exit_decision.get(
                                        "original_tp", new_tp_percent
                                    )
                                    tsl.original_tp_percent = original_tp
                                    logger.debug(
                                        f"ЁЯУМ ╨б╨╛╤Е╤А╨░╨╜╨╕╨╗╨╕ ╨╛╤А╨╕╨│╨╕╨╜╨░╨╗╤М╨╜╤Л╨╣ TP ╨┤╨╗╤П {symbol}: {original_tp:.2f}%"
                                    )

                                # ╨г╨▓╨╡╨╗╨╕╤З╨╕╨▓╨░╨╡╨╝ TP ╨▓ ╨╝╨╡╤В╨░╨┤╨░╨╜╨╜╤Л╤Е TSL (╨╕╤Б╨┐╨╛╨╗╤М╨╖╤Г╨╡╤В╤Б╤П ╨┤╨╗╤П ╨╗╨╛╨│╨╕╤А╨╛╨▓╨░╨╜╨╕╤П ╨╕ ╨░╨╜╨░╨╗╨╕╨╖╨░)
                                tsl.extended_tp_percent = new_tp_percent
                                tsl.tp_extended_count = (
                                    getattr(tsl, "tp_extended_count", 0) + 1
                                )

                                logger.info(
                                    f"тЬЕ TP ╨┐╤А╨╛╨┤╨╗╨╡╨╜ ╨┤╨╗╤П {symbol}: {tsl.original_tp_percent:.2f}% тЖТ {new_tp_percent:.2f}% "
                                    f"(╨┐╤А╨╛╨┤╨╗╨╡╨╜╨╕╨╣: {tsl.tp_extended_count})"
                                )

                            # ╨Я╤А╨╛╨┤╨╛╨╗╨╢╨░╨╡╨╝ - TSL ╨▒╤Г╨┤╨╡╤В ╤А╨░╨▒╨╛╤В╨░╤В╤М ╤Б ╨╜╨╛╨▓╤Л╨╝╨╕ ╨┐╨░╤А╨░╨╝╨╡╤В╤А╨░╨╝╨╕
                        # тЬЕ ╨Х╤Б╨╗╨╕ ExitAnalyzer ╨▓╨╡╤А╨╜╤Г╨╗ "hold" - ╨┐╤А╨╛╤Б╤В╨╛ ╨┐╤А╨╛╨┤╨╛╨╗╨╢╨░╨╡╨╝ ╨╝╨╛╨╜╨╕╤В╨╛╤А╨╕╨╜╨│
                        elif action == "hold":
                            hold_reason = exit_decision.get("reason", "hold")
                            logger.debug(
                                f"тП╕я╕П ExitAnalyzer: ╨Ф╨╡╤А╨╢╨╕╨╝ ╨┐╨╛╨╖╨╕╤Ж╨╕╤О {symbol} (reason={hold_reason})"
                            )
                            # ╨Я╤А╨╛╨┤╨╛╨╗╨╢╨░╨╡╨╝ ╨╝╨╛╨╜╨╕╤В╨╛╤А╨╕╨╜╨│ - ╨╜╨╡ ╨╖╨░╨║╤А╤Л╨▓╨░╨╡╨╝
                        # тЬЕ ╨Х╤Б╨╗╨╕ action ╨╜╨╡ ╤А╨░╤Б╨┐╨╛╨╖╨╜╨░╨╜ - ╨╗╨╛╨│╨╕╤А╤Г╨╡╨╝ ╨╕ ╨┐╤А╨╛╨┤╨╛╨╗╨╢╨░╨╡╨╝
                        else:
                            logger.warning(
                                f"тЪая╕П ExitAnalyzer: ╨Э╨╡╨╕╨╖╨▓╨╡╤Б╤В╨╜╤Л╨╣ action={action} ╨┤╨╗╤П {symbol}, ╨┐╤А╨╛╨┤╨╛╨╗╨╢╨░╨╡╨╝ ╨╝╨╛╨╜╨╕╤В╨╛╤А╨╕╨╜╨│"
                            )
                except Exception as e:
                    logger.error(
                        f"тЭМ ExitAnalyzer: ╨Ю╤И╨╕╨▒╨║╨░ ╨░╨╜╨░╨╗╨╕╨╖╨░ ╨┤╨╗╤П {symbol}: {e}",
                        exc_info=True,
                    )

            should_close_by_sl, close_reason = tsl.should_close_position(
                current_price,
                trend_strength=trend_strength,
                market_regime=market_regime,
                margin_used=margin_used if margin_used and margin_used > 0 else None,
                unrealized_pnl=unrealized_pnl if unrealized_pnl is not None else None,
            )

            should_block_close = False
            if should_close_by_sl and profit_pct > 0:
                # тЬЕ ╨н╨в╨Р╨Я 1.1: ╨Р╨╜╨░╨╗╨╕╨╖ ╤А╨░╨╖╨▓╨╛╤А╨╛╤В╨░ Order Flow (╨┐╤А╨╕╨╛╤А╨╕╤В╨╡╤В 1)
                order_flow_reversal_detected = False
                if self.order_flow:
                    try:
                        current_delta = self.order_flow.get_delta()
                        avg_delta = self.order_flow.get_avg_delta(periods=10)

                        # ╨б╨╛╤Е╤А╨░╨╜╤П╨╡╨╝ ╨╕╤Б╤В╨╛╤А╨╕╤О delta ╨┤╨╗╤П ╨░╨╜╨░╨╗╨╕╨╖╨░ ╤А╨░╨╖╨▓╨╛╤А╨╛╤В╨░
                        if symbol not in self._order_flow_delta_history:
                            self._order_flow_delta_history[symbol] = []
                        self._order_flow_delta_history[symbol].append(
                            (time.time(), current_delta)
                        )
                        # ╨е╤А╨░╨╜╨╕╨╝ ╨╕╤Б╤В╨╛╤А╨╕╤О ╨╖╨░ ╨┐╨╛╤Б╨╗╨╡╨┤╨╜╨╕╨╡ 5 ╨╝╨╕╨╜╤Г╤В
                        cutoff_time = time.time() - 300
                        self._order_flow_delta_history[symbol] = [
                            (t, d)
                            for t, d in self._order_flow_delta_history[symbol]
                            if t > cutoff_time
                        ]

                        # ╨Я╨╛╨╗╤Г╤З╨░╨╡╨╝ ╨┐╨░╤А╨░╨╝╨╡╤В╤А╤Л ╨╕╨╖ ╨║╨╛╨╜╤Д╨╕╨│╨░
                        reversal_config = getattr(
                            self.scalping_config, "position_manager", {}
                        ).get("reversal_detection", {})
                        order_flow_config = reversal_config.get("order_flow", {})
                        enabled = order_flow_config.get("enabled", True)
                        reversal_threshold = order_flow_config.get(
                            "reversal_threshold", 0.15
                        )  # 15% ╨╕╨╖╨╝╨╡╨╜╨╡╨╜╨╕╨╡ delta

                        if enabled and len(self._order_flow_delta_history[symbol]) >= 2:
                            # ╨Р╨╜╨░╨╗╨╕╨╖╨╕╤А╤Г╨╡╨╝ ╨╕╨╖╨╝╨╡╨╜╨╡╨╜╨╕╨╡ delta ╨╖╨░ ╨┐╨╛╤Б╨╗╨╡╨┤╨╜╨╕╨╡ ╨┐╨╡╤А╨╕╨╛╨┤╤Л
                            recent_deltas = [
                                d
                                for _, d in self._order_flow_delta_history[symbol][-10:]
                            ]
                            if len(recent_deltas) >= 2:
                                # ╨Я╤А╨╛╨▓╨╡╤А╤П╨╡╨╝ ╤А╨░╨╖╨▓╨╛╤А╨╛╤В: ╨┤╨╗╤П LONG ╨┐╨╛╨╖╨╕╤Ж╨╕╨╕ delta ╨┤╨╛╨╗╨╢╨╡╨╜ ╨▒╤Л╨╗ ╨▒╤Л╤В╤М ╨┐╨╛╨╗╨╛╨╢╨╕╤В╨╡╨╗╤М╨╜╤Л╨╝ ╨╕ ╤Б╤В╨░╤В╤М ╨╛╤В╤А╨╕╤Ж╨░╤В╨╡╨╗╤М╨╜╤Л╨╝
                                if position_side.lower() == "long":
                                    # ╨Ф╨╗╤П LONG: ╤А╨░╨╖╨▓╨╛╤А╨╛╤В = delta ╨▒╤Л╨╗ > threshold ╨╕ ╤Б╤В╨░╨╗ < -threshold
                                    prev_delta = (
                                        recent_deltas[-2]
                                        if len(recent_deltas) >= 2
                                        else avg_delta
                                    )
                                    if (
                                        prev_delta > reversal_threshold
                                        and current_delta < -reversal_threshold
                                    ):
                                        order_flow_reversal_detected = True
                                        logger.info(
                                            f"ЁЯФД Order Flow ╤А╨░╨╖╨▓╨╛╤А╨╛╤В ╨╛╨▒╨╜╨░╤А╤Г╨╢╨╡╨╜ ╨┤╨╗╤П {symbol} LONG: "
                                            f"delta {prev_delta:.3f} тЖТ {current_delta:.3f} "
                                            f"(╨┐╨╛╨║╤Г╨┐╨░╤В╨╡╨╗╨╕ тЖТ ╨┐╤А╨╛╨┤╨░╨▓╤Ж╤Л, ╨╖╨░╨║╤А╤Л╨▓╨░╨╡╨╝ ╨┐╨╛╨╖╨╕╤Ж╨╕╤О)"
                                        )
                                elif position_side.lower() == "short":
                                    # ╨Ф╨╗╤П SHORT: ╤А╨░╨╖╨▓╨╛╤А╨╛╤В = delta ╨▒╤Л╨╗ < -threshold ╨╕ ╤Б╤В╨░╨╗ > threshold
                                    prev_delta = (
                                        recent_deltas[-2]
                                        if len(recent_deltas) >= 2
                                        else avg_delta
                                    )
                                    if (
                                        prev_delta < -reversal_threshold
                                        and current_delta > reversal_threshold
                                    ):
                                        order_flow_reversal_detected = True
                                        logger.info(
                                            f"ЁЯФД Order Flow ╤А╨░╨╖╨▓╨╛╤А╨╛╤В ╨╛╨▒╨╜╨░╤А╤Г╨╢╨╡╨╜ ╨┤╨╗╤П {symbol} SHORT: "
                                            f"delta {prev_delta:.3f} тЖТ {current_delta:.3f} "
                                            f"(╨┐╤А╨╛╨┤╨░╨▓╤Ж╤Л тЖТ ╨┐╨╛╨║╤Г╨┐╨░╤В╨╡╨╗╨╕, ╨╖╨░╨║╤А╤Л╨▓╨░╨╡╨╝ ╨┐╨╛╨╖╨╕╤Ж╨╕╤О)"
                                        )
                    except Exception as e:
                        logger.debug(
                            f"тЪая╕П ╨Ю╤И╨╕╨▒╨║╨░ ╨░╨╜╨░╨╗╨╕╨╖╨░ Order Flow ╤А╨░╨╖╨▓╨╛╤А╨╛╤В╨░ ╨┤╨╗╤П {symbol}: {e}"
                        )

                # ╨Х╤Б╨╗╨╕ Order Flow ╨┐╨╛╨║╨░╨╖╤Л╨▓╨░╨╡╤В ╤А╨░╨╖╨▓╨╛╤А╨╛╤В - ╨╖╨░╨║╤А╤Л╨▓╨░╨╡╨╝ ╨┐╨╛╨╖╨╕╤Ж╨╕╤О (╨╜╨╡ ╨▒╨╗╨╛╨║╨╕╤А╤Г╨╡╨╝)
                if order_flow_reversal_detected:
                    logger.info(
                        f"ЁЯФД ╨Ч╨░╨║╤А╤Л╨▓╨░╨╡╨╝ {symbol} ╨┐╨╛ Order Flow ╤А╨░╨╖╨▓╨╛╤А╨╛╤В╤Г "
                        f"(profit={profit_pct:.2%}, delta ╨╕╨╖╨╝╨╡╨╜╨╕╨╗╤Б╤П)"
                    )
                    if self.debug_logger:
                        entry_time = position.get("entry_time")
                        if isinstance(entry_time, datetime):
                            # тЬЕ ╨Ш╨б╨Я╨а╨Р╨Т╨Ы╨Х╨Э╨Ш╨Х: ╨г╨▒╨╡╨╢╨┤╨░╨╡╨╝╤Б╤П, ╤З╤В╨╛ entry_time ╨▓ UTC
                            if entry_time.tzinfo is None:
                                entry_time = entry_time.replace(tzinfo=timezone.utc)
                            elif entry_time.tzinfo != timezone.utc:
                                entry_time = entry_time.astimezone(timezone.utc)
                            minutes_in_position = (
                                datetime.now(timezone.utc) - entry_time
                            ).total_seconds() / 60.0
                        elif tsl.entry_timestamp > 0:
                            minutes_in_position = (
                                time.time() - tsl.entry_timestamp
                            ) / 60.0
                        else:
                            minutes_in_position = 0.0
                        self.debug_logger.log_position_close(
                            symbol=symbol,
                            exit_price=current_price,
                            # profit_pct ╨╖╨┤╨╡╤Б╤М ╨▓ ╨┤╨╛╨╗╤П╤Е (0.005 = 0.5% ╨╛╤В ╨╝╨░╤А╨╢╨╕)
                            pnl_usd=(profit_pct * float(position.get("margin", 0)))
                            if position.get("margin")
                            else 0.0,
                            pnl_pct=profit_pct,
                            time_in_position_minutes=minutes_in_position,
                            reason="order_flow_reversal",
                        )
                    if self._has_position(symbol):
                        await self.close_position_callback(
                            symbol, "order_flow_reversal"
                        )
                    return

                reversal_config = getattr(
                    self.scalping_config, "position_manager", {}
                ).get("reversal_detection", {})

                if reversal_config.get("enabled", False):
                    try:
                        pos_side = position_side

                        if hasattr(self.signal_generator, "_get_market_data"):
                            market_data = await self.signal_generator._get_market_data(
                                symbol
                            )
                        else:
                            market_data = None
                        if market_data and getattr(market_data, "ohlcv_data", None):
                            indicators = (
                                self.signal_generator.indicator_manager.calculate_all(
                                    market_data
                                )
                            )

                            if reversal_config.get("rsi_check", True):
                                rsi_result = indicators.get("RSI") or indicators.get(
                                    "rsi"
                                )
                                if rsi_result:
                                    rsi_value = (
                                        rsi_result.value
                                        if hasattr(rsi_result, "value")
                                        else rsi_result
                                    )
                                    if pos_side == "long" and rsi_value < 30:
                                        logger.debug(
                                            f"ЁЯУК RSI ╨┐╨╡╤А╨╡╨┐╤А╨╛╨┤╨░╨╜ ({rsi_value:.1f}) ╨┤╨╗╤П {symbol} LONG - "
                                            f"╨▒╨╗╨╛╨║╨╕╤А╤Г╨╡╨╝ ╨╖╨░╨║╤А╤Л╤В╨╕╨╡ ╨┐╨╛ trailing stop (╨┐╨╛╨╖╨╕╤Ж╨╕╤П ╨▓ ╨┐╤А╨╕╨▒╤Л╨╗╨╕)"
                                        )
                                        should_block_close = True
                                    if pos_side == "short" and rsi_value > 70:
                                        logger.debug(
                                            f"ЁЯУК RSI ╨┐╨╡╤А╨╡╨║╤Г╨┐╨╗╨╡╨╜ ({rsi_value:.1f}) ╨┤╨╗╤П {symbol} SHORT - "
                                            f"╨▒╨╗╨╛╨║╨╕╤А╤Г╨╡╨╝ ╨╖╨░╨║╤А╤Л╤В╨╕╨╡ ╨┐╨╛ trailing stop (╨┐╨╛╨╖╨╕╤Ж╨╕╤П ╨▓ ╨┐╤А╨╕╨▒╤Л╨╗╨╕)"
                                        )
                                        should_block_close = True

                            if (
                                reversal_config.get("macd_check", True)
                                and not should_block_close
                            ):
                                macd_result = indicators.get("MACD") or indicators.get(
                                    "macd"
                                )
                                if macd_result and hasattr(macd_result, "metadata"):
                                    macd_line = macd_result.metadata.get("macd_line", 0)
                                    signal_line = macd_result.metadata.get(
                                        "signal_line", 0
                                    )
                                    histogram = macd_line - signal_line

                                    if pos_side == "long" and histogram > 0:
                                        logger.debug(
                                            f"ЁЯУК MACD ╨▒╤Л╤З╤М╤П ╨┤╨╕╨▓╨╡╤А╨│╨╡╨╜╤Ж╨╕╤П ╨┤╨╗╤П {symbol} LONG - "
                                            f"╨▒╨╗╨╛╨║╨╕╤А╤Г╨╡╨╝ ╨╖╨░╨║╤А╤Л╤В╨╕╨╡ ╨┐╨╛ trailing stop (╨┐╨╛╨╖╨╕╤Ж╨╕╤П ╨▓ ╨┐╤А╨╕╨▒╤Л╨╗╨╕)"
                                        )
                                        should_block_close = True

                                    if pos_side == "short" and histogram < 0:
                                        logger.debug(
                                            f"ЁЯУК MACD ╨╝╨╡╨┤╨▓╨╡╨╢╤М╤П ╨┤╨╕╨▓╨╡╤А╨│╨╡╨╜╤Ж╨╕╤П ╨┤╨╗╤П {symbol} SHORT - "
                                            f"╨▒╨╗╨╛╨║╨╕╤А╤Г╨╡╨╝ ╨╖╨░╨║╤А╤Л╤В╨╕╨╡ ╨┐╨╛ trailing stop (╨┐╨╛╨╖╨╕╤Ж╨╕╤П ╨▓ ╨┐╤А╨╕╨▒╤Л╨╗╨╕)"
                                        )
                                        should_block_close = True

                            if (
                                reversal_config.get("bollinger_check", True)
                                and not should_block_close
                            ):
                                bb_result = indicators.get(
                                    "BollingerBands"
                                ) or indicators.get("bollinger_bands")
                                if bb_result and hasattr(bb_result, "metadata"):
                                    upper = bb_result.metadata.get(
                                        "upper_band", current_price
                                    )
                                    lower = bb_result.metadata.get(
                                        "lower_band", current_price
                                    )
                                    middle = (
                                        bb_result.value
                                        if hasattr(bb_result, "value")
                                        else current_price
                                    )

                                    if (
                                        pos_side == "long"
                                        and current_price <= lower * 1.001
                                    ):
                                        logger.debug(
                                            f"ЁЯУК ╨ж╨╡╨╜╨░ ╤Г ╨╜╨╕╨╢╨╜╨╡╨╣ ╨┐╨╛╨╗╨╛╤Б╤Л Bollinger ╨┤╨╗╤П {symbol} LONG - "
                                            f"╨▒╨╗╨╛╨║╨╕╤А╤Г╨╡╨╝ ╨╖╨░╨║╤А╤Л╤В╨╕╨╡ ╨┐╨╛ trailing stop (╨┐╨╛╨╖╨╕╤Ж╨╕╤П ╨▓ ╨┐╤А╨╕╨▒╤Л╨╗╨╕)"
                                        )
                                        should_block_close = True

                                    if (
                                        pos_side == "short"
                                        and current_price >= upper * 0.999
                                    ):
                                        logger.debug(
                                            f"ЁЯУК ╨ж╨╡╨╜╨░ ╤Г ╨▓╨╡╤А╤Е╨╜╨╡╨╣ ╨┐╨╛╨╗╨╛╤Б╤Л Bollinger ╨┤╨╗╤П {symbol} SHORT - "
                                            f"╨▒╨╗╨╛╨║╨╕╤А╤Г╨╡╨╝ ╨╖╨░╨║╤А╤Л╤В╨╕╨╡ ╨┐╨╛ trailing stop (╨┐╨╛╨╖╨╕╤Ж╨╕╤П ╨▓ ╨┐╤А╨╕╨▒╤Л╨╗╨╕)"
                                        )
                                        should_block_close = True
                    except Exception as e:
                        logger.debug(
                            f"тЪая╕П ╨Ю╤И╨╕╨▒╨║╨░ ╨┐╤А╨╛╨▓╨╡╤А╨║╨╕ ╨╕╨╜╨┤╨╕╨║╨░╤В╨╛╤А╨╛╨▓ ╨┤╨╗╤П {symbol}: {e}"
                        )

            if should_close_by_sl:
                if should_block_close:
                    logger.debug(
                        f"ЁЯФТ ╨Ч╨░╨║╤А╤Л╤В╨╕╨╡ ╨┐╨╛ trailing stop ╨╖╨░╨▒╨╗╨╛╨║╨╕╤А╨╛╨▓╨░╨╜╨╛ ╨┤╨╗╤П {symbol} "
                        f"(╨╕╨╜╨┤╨╕╨║╨░╤В╨╛╤А╤Л ╨┐╨╛╨║╨░╨╖╤Л╨▓╨░╤О╤В ╨▓╨╛╨╖╨╝╨╛╨╢╨╜╤Л╨╣ ╤А╨░╨╖╨▓╨╛╤А╨╛╤В ╨▓ ╨╜╨░╤И╤Г ╨┐╨╛╨╗╤М╨╖╤Г, ╨┐╨╛╨╖╨╕╤Ж╨╕╤П ╨▓ ╨┐╤А╨╕╨▒╤Л╨╗╨╕)"
                    )
                    return

                trend_str_close = (
                    f"{trend_strength:.2f}" if trend_strength is not None else "N/A"
                )
                comparison_op = ">=" if position_side.lower() == "short" else "<="
                entry_time = position.get("entry_time")
                if isinstance(entry_time, datetime):
                    minutes_in_position = (
                        datetime.now() - entry_time
                    ).total_seconds() / 60.0
                elif tsl.entry_timestamp > 0:
                    minutes_in_position = (time.time() - tsl.entry_timestamp) / 60.0
                else:
                    minutes_in_position = 0.0
                reason_str = close_reason or "trailing_stop"
                logger.info(
                    f"ЁЯУК ╨Ч╨░╨║╤А╤Л╨▓╨░╨╡╨╝ {symbol} ╨┐╨╛ ╨┐╤А╨╕╤З╨╕╨╜╨╡: {reason_str} "
                    f"(price={current_price:.2f} {comparison_op} stop={stop_loss:.2f}, "
                    f"profit={profit_pct:.2%}, time={minutes_in_position:.2f} ╨╝╨╕╨╜, trend={trend_str_close})"
                )
                if self.debug_logger:
                    self.debug_logger.log_position_close(
                        symbol=symbol,
                        exit_price=current_price,
                        # profit_pct ╨╖╨┤╨╡╤Б╤М ╨▓ ╨┤╨╛╨╗╤П╤Е (0.005 = 0.5% ╨╛╤В ╨╝╨░╤А╨╢╨╕)
                        pnl_usd=(profit_pct * float(position.get("margin", 0)))
                        if position.get("margin")
                        else 0.0,
                        pnl_pct=profit_pct,
                        time_in_position_minutes=minutes_in_position,
                        reason=reason_str,
                    )
                if self._has_position(symbol):
                    await self.close_position_callback(symbol, reason_str)
                else:
                    logger.debug(
                        f"тЪая╕П ╨Я╨╛╨╖╨╕╤Ж╨╕╤П {symbol} ╤Г╨╢╨╡ ╨▒╤Л╨╗╨░ ╨╖╨░╨║╤А╤Л╤В╨░, ╨┐╤А╨╛╨┐╤Г╤Б╨║╨░╨╡╨╝ ╨╖╨░╨║╤А╤Л╤В╨╕╨╡"
                    )
                return

            if self.position_manager:
                position_data = position
                if position_data:
                    entry_time = position_data.get("entry_time")
                    if isinstance(entry_time, datetime):
                        entry_time_ms = int(entry_time.timestamp() * 1000)
                    elif entry_time:
                        entry_time_ms = (
                            int(float(entry_time) * 1000)
                            if float(entry_time) < 1000000000000
                            else int(entry_time)
                        )
                    else:
                        entry_time_ms = ""

                    position_dict = {
                        "instId": f"{symbol}-SWAP",
                        "pos": str(
                            position_data.get("size", position_data.get("pos", "0"))
                            or "0"
                        ),
                        "posSide": position_data.get(
                            "position_side", position_data.get("posSide", "long")
                        ),
                        "avgPx": str(entry_price),
                        "markPx": str(current_price),
                        "cTime": str(entry_time_ms) if entry_time_ms else "",
                    }

                    ph_should_close = (
                        await self.position_manager._check_profit_harvesting(
                            position_dict
                        )
                    )
                    if ph_should_close:
                        logger.info(
                            f"ЁЯТ░ PH ╤Б╤А╨░╨▒╨╛╤В╨░╨╗ ╨┤╨╗╤П {symbol} - ╨╖╨░╨║╤А╤Л╨▓╨░╨╡╨╝ ╨┐╨╛╨╖╨╕╤Ж╨╕╤О ╨╜╨╡╨╝╨╡╨┤╨╗╨╡╨╜╨╜╨╛!"
                        )
                        await self.close_position_callback(symbol, "profit_harvest")
                        return

            await self._check_position_holding_time(
                symbol, current_price, profit_pct, market_regime
            )

        except Exception as e:
            logger.error(f"╨Ю╤И╨╕╨▒╨║╨░ ╨╛╨▒╨╜╨╛╨▓╨╗╨╡╨╜╨╕╤П ╤В╤А╨╡╨╣╨╗╨╕╨╜╨│ ╤Б╤В╨╛╨┐-╨╗╨╛╤Б╤Б╨░: {e}")

    async def periodic_check(self):
        """
        ╨Я╨╡╤А╨╕╨╛╨┤╨╕╤З╨╡╤Б╨║╨░╤П ╨┐╤А╨╛╨▓╨╡╤А╨║╨░ Trailing Stop Loss ╨┤╨╗╤П ╨▓╤Б╨╡╤Е ╨┐╨╛╨╖╨╕╤Ж╨╕╨╣ ╤Б ╨░╨┤╨░╨┐╤В╨╕╨▓╨╜╤Л╨╝ ╨╕╨╜╤В╨╡╤А╨▓╨░╨╗╨╛╨╝.
        """
        try:
            has_active_positions = bool(
                self.active_positions_ref and len(self.active_positions_ref) > 0
            )
            if not self.trailing_sl_by_symbol and not has_active_positions:
                return

            current_time = time.time()

            current_regime = "ranging"
            try:
                if (
                    hasattr(self.signal_generator, "regime_manager")
                    and self.signal_generator.regime_manager
                ):
                    regime_obj = (
                        self.signal_generator.regime_manager.get_current_regime()
                    )
                    if regime_obj:
                        current_regime = (
                            regime_obj.lower()
                            if isinstance(regime_obj, str)
                            else str(regime_obj).lower()
                        )
            except Exception:
                pass

            check_interval = self._tsl_check_interval
            if current_regime in self._tsl_check_intervals_by_regime:
                check_interval = self._tsl_check_intervals_by_regime[current_regime]
            else:
                try:
                    tsl_config = getattr(self.scalping_config, "trailing_sl", {})
                    by_regime = getattr(tsl_config, "by_regime", None)
                    if by_regime:
                        regime_config = getattr(by_regime, current_regime, None)
                        if regime_config:
                            regime_interval = getattr(
                                regime_config, "check_interval_seconds", None
                            )
                            if regime_interval:
                                check_interval = float(regime_interval)
                                self._tsl_check_intervals_by_regime[
                                    current_regime
                                ] = check_interval
                except Exception:
                    pass

            symbols_to_check = list(self.trailing_sl_by_symbol.keys())
            if self.active_positions_ref:
                for symbol in self.active_positions_ref.keys():
                    if symbol not in symbols_to_check:
                        symbols_to_check.append(symbol)

            if not symbols_to_check:
                return

            for symbol in symbols_to_check:
                try:
                    last_check = self._last_tsl_check_time.get(symbol, 0.0)
                    if current_time - last_check < check_interval:
                        continue
                    self._last_tsl_check_time[symbol] = current_time

                    # тЬЕ ╨Ш╨б╨Я╨а╨Р╨Т╨Ы╨Х╨Э╨Ш╨Х (09.01.2026): ╨Ф╨╛╨▒╨░╨▓╨╗╨╡╨╜ price=0 guardrail ╤Б retry
                    current_price = await self._get_current_price(symbol)
                    if current_price is None or current_price == 0:
                        logger.warning(
                            f"тЪая╕П {symbol}: ╨Я╨╛╨╗╤Г╤З╨╡╨╜╨░ ╨╜╨╡╨║╨╛╤А╤А╨╡╨║╤В╨╜╨░╤П ╤Ж╨╡╨╜╨░ ╨┐╤А╨╕ ╨┐╤А╨╛╨▓╨╡╤А╨║╨╡ TSL (price={current_price}), "
                            f"╨┐╤Л╤В╨░╨╡╨╝╤Б╤П ╨┐╨╛╨▓╤В╨╛╤А╨╜╨╛ ╤З╨╡╤А╨╡╨╖ 1 ╤Б╨╡╨║..."
                        )
                        await asyncio.sleep(1)
                        current_price = await self._get_current_price(symbol)

                        if current_price is None or current_price == 0:
                            # ╨Х╤Б╨╗╨╕ ╤Б╨╜╨╛╨▓╨░ price=0, ╨┐╤А╨╛╨┐╤Г╤Б╨║╨░╨╡╨╝ ╨┐╤А╨╛╨▓╨╡╤А╨║╤Г
                            logger.error(
                                f"тЭМ {symbol}: ╨Э╨╡ ╤Г╨┤╨░╨╗╨╛╤Б╤М ╨┐╨╛╨╗╤Г╤З╨╕╤В╤М ╨▓╨░╨╗╨╕╨┤╨╜╤Г╤О ╤Ж╨╡╨╜╤Г ╨┐╨╛╤Б╨╗╨╡ ╨┐╨╛╨▓╤В╨╛╤А╨╜╨╛╨╣ ╨┐╨╛╨┐╤Л╤В╨║╨╕ "
                                f"(price={current_price}), ╨┐╤А╨╛╨┐╤Г╤Б╨║╨░╨╡╨╝ ╨┐╤А╨╛╨▓╨╡╤А╨║╤Г TSL"
                            )
                            continue

                    if current_price and current_price > 0:
                        await self.update_trailing_stop_loss(symbol, current_price)
                    else:
                        logger.debug(
                            f"тЪая╕П ╨Э╨╡ ╤Г╨┤╨░╨╗╨╛╤Б╤М ╨┐╨╛╨╗╤Г╤З╨╕╤В╤М ╤Ж╨╡╨╜╤Г ╨┤╨╗╤П {symbol} ╨┐╤А╨╕ ╨┐╨╡╤А╨╕╨╛╨┤╨╕╤З╨╡╤Б╨║╨╛╨╣ ╨┐╤А╨╛╨▓╨╡╤А╨║╨╡ TSL"
                        )
                except Exception as e:
                    logger.debug(
                        f"тЪая╕П ╨Ю╤И╨╕╨▒╨║╨░ ╨┐╨╡╤А╨╕╨╛╨┤╨╕╤З╨╡╤Б╨║╨╛╨╣ ╨┐╤А╨╛╨▓╨╡╤А╨║╨╕ TSL ╨┤╨╗╤П {symbol}: {e}"
                    )
        except Exception as e:
            logger.error(f"тЭМ ╨Ю╤И╨╕╨▒╨║╨░ ╨▓ periodic_check: {e}")

    async def _get_current_price(self, symbol: str) -> Optional[float]:
        """
        тЬЕ ╨Ш╨б╨Я╨а╨Р╨Т╨Ы╨Х╨Э╨Ш╨Х (09.01.2026): ╨Я╨╛╨╗╤Г╤З╨╡╨╜╨╕╨╡ ╤В╨╡╨║╤Г╤Й╨╡╨╣ ╤Ж╨╡╨╜╤Л ╤Б ╨┐╤А╨╕╨╛╤А╨╕╤В╨╡╤В╨╛╨╝ ╨╜╨░ WebSocket real-time.

        ╨Ш╨╡╤А╨░╤А╤Е╨╕╤П ╨╕╤Б╤В╨╛╤З╨╜╨╕╨║╨╛╨▓ (╨┐╤А╨╕╨╛╤А╨╕╤В╨╡╤В):
        1. WebSocket real-time ╨╕╨╖ DataRegistry (current_tick) - <100ms
        2. ╨Я╨╛╤Б╨╗╨╡╨┤╨╜╤П╤П ╤Б╨▓╨╡╤З╨░ ╨╕╨╖ DataRegistry (ohlcv_data) - fallback ╨╡╤Б╨╗╨╕ WebSocket ╨╜╨╡╨┤╨╛╤Б╤В╤Г╨┐╨╡╨╜
        3. REST API callback (╨╝╨╡╨┤╨╗╨╡╨╜╨╜╨╛, ╨╜╨╛ ╨╜╨░╨┤╨╡╨╢╨╜╨╛) - fallback ╨╡╤Б╨╗╨╕ DataRegistry ╨╜╨╡╨┤╨╛╤Б╤В╤Г╨┐╨╜╨░
        4. REST API client fallback - emergency

        Returns:
            float: ╨в╨╡╨║╤Г╤Й╨░╤П ╤Ж╨╡╨╜╨░ ╨╕╨╗╨╕ None
        """
        # тЬЕ ╨Я╨а╨Ш╨Ю╨а╨Ш╨в╨Х╨в 1: WebSocket real-time ╨╕╨╖ DataRegistry
        try:
            if (
                hasattr(self, "position_registry")
                and self.position_registry
                and hasattr(self.position_registry, "data_registry")
            ):
                market_data = (
                    await self.position_registry.data_registry.get_market_data(symbol)
                )
                if (
                    market_data
                    and hasattr(market_data, "current_tick")
                    and market_data.current_tick
                ):
                    if (
                        hasattr(market_data.current_tick, "price")
                        and market_data.current_tick.price > 0
                    ):
                        logger.debug(
                            f"тЬЕ TSL: WebSocket real-time price for {symbol}: {market_data.current_tick.price:.8f}"
                        )
                        return market_data.current_tick.price
        except Exception as e:
            logger.debug(f"тЪая╕П TSL: Failed to get DataRegistry market_data: {e}")

        # тЬЕ ╨Я╨а╨Ш╨Ю╨а╨Ш╨в╨Х╨в 2: Fallback ╨╜╨░ ╨┐╨╛╤Б╨╗╨╡╨┤╨╜╤О╤О ╤Б╨▓╨╡╤З╤Г ╨╕╨╖ DataRegistry
        try:
            if (
                hasattr(self, "position_registry")
                and self.position_registry
                and hasattr(self.position_registry, "data_registry")
            ):
                market_data = (
                    await self.position_registry.data_registry.get_market_data(symbol)
                )
                if (
                    market_data
                    and hasattr(market_data, "ohlcv_data")
                    and market_data.ohlcv_data
                ):
                    last_candle_price = market_data.ohlcv_data[-1].close
                    logger.debug(
                        f"тЪая╕П TSL: Using last candle (DataRegistry) for {symbol}: {last_candle_price:.8f}"
                    )
                    return last_candle_price
        except Exception as e:
            logger.debug(f"тЪая╕П TSL: Failed to get last candle from DataRegistry: {e}")

        # тЬЕ ╨Я╨а╨Ш╨Ю╨а╨Ш╨в╨Х╨в 3: REST API callback (╨╝╨╡╨┤╨╗╨╡╨╜╨╜╨╡╨╡ ╤З╨╡╨╝ WebSocket, ╨╜╨╛ ╨▓╤Б╨╡ ╨╡╤Й╨╡ OK)
        if self.get_current_price_callback:
            try:
                price = await self.get_current_price_callback(symbol)
                if price and price > 0:
                    logger.debug(
                        f"тЪая╕П TSL: Using REST API callback for {symbol}: {price:.8f}"
                    )
                    return price
            except TypeError:
                # ╨Э╨░ ╤Б╨╗╤Г╤З╨░╨╣ ╨╡╤Б╨╗╨╕ ╨┐╨╡╤А╨╡╨┤╨░╨╜╨░ ╤Б╨╕╨╜╤Е╤А╨╛╨╜╨╜╨░╤П ╤Д╤Г╨╜╨║╤Ж╨╕╤П
                try:
                    price = self.get_current_price_callback(symbol)
                    if price and price > 0:
                        logger.debug(
                            f"тЪая╕П TSL: Using sync REST API callback for {symbol}: {price:.8f}"
                        )
                        return price
                except Exception as e:
                    logger.debug(f"тЪая╕П TSL: Sync callback failed for {symbol}: {e}")
            except Exception as e:
                logger.debug(f"тЪая╕П TSL: Async callback failed for {symbol}: {e}")

        # тЬЕ ╨Я╨а╨Ш╨Ю╨а╨Ш╨в╨Х╨в 4: REST API client fallback (emergency)
        logger.warning(f"ЁЯФ┤ TSL: Falling back to REST API client for {symbol}")
        return await self._fetch_price_via_client(symbol)

    async def _fetch_price_via_client(self, symbol: str) -> Optional[float]:
        """
        ╨Я╨╛╨╗╤Г╤З╨╡╨╜╨╕╨╡ ╤В╨╡╨║╤Г╤Й╨╡╨╣ ╤Ж╨╡╨╜╤Л ╤З╨╡╤А╨╡╨╖ ╨┐╤Г╨▒╨╗╨╕╤З╨╜╤Л╨╣ REST endpoint OKX.
        """
        try:
            import aiohttp

            inst_id = f"{symbol}-SWAP"
            base_url = "https://www.okx.com"
            ticker_url = f"{base_url}/api/v5/market/ticker?instId={inst_id}"

            session = (
                self.client.session
                if getattr(self.client, "session", None)
                and not self.client.session.closed
                else None
            )
            if not session:
                session = aiohttp.ClientSession()
                close_session = True
            else:
                close_session = False

            try:
                async with session.get(ticker_url) as ticker_resp:
                    if ticker_resp.status == 200:
                        ticker_data = await ticker_resp.json()
                        if ticker_data and ticker_data.get("code") == "0":
                            data = ticker_data.get("data", [])
                            if data:
                                last_price = data[0].get("last")
                                if last_price:
                                    return float(last_price)
                    else:
                        logger.debug(
                            f"тЪая╕П ╨Э╨╡ ╤Г╨┤╨░╨╗╨╛╤Б╤М ╨┐╨╛╨╗╤Г╤З╨╕╤В╤М ╤Ж╨╡╨╜╤Г ╨┤╨╗╤П {symbol}: HTTP {ticker_resp.status}"
                        )
            finally:
                if close_session and session:
                    await session.close()

            logger.debug(f"тЪая╕П ╨Э╨╡ ╤Г╨┤╨░╨╗╨╛╤Б╤М ╨┐╨╛╨╗╤Г╤З╨╕╤В╤М ╤Ж╨╡╨╜╤Г ╨┤╨╗╤П {symbol} ╤З╨╡╤А╨╡╨╖ REST API")
            return None

        except Exception as e:
            logger.debug(f"тЪая╕П ╨Ю╤И╨╕╨▒╨║╨░ ╨┐╨╛╨╗╤Г╤З╨╡╨╜╨╕╤П ╤Ж╨╡╨╜╤Л ╨┤╨╗╤П {symbol}: {e}")
            return None

    async def _check_position_holding_time(
        self,
        symbol: str,
        current_price: float,
        profit_pct: float,
        market_regime: Optional[str] = None,
    ):
        """╨Я╤А╨╛╨▓╨╡╤А╨║╨░ ╨▓╤А╨╡╨╝╨╡╨╜╨╕ ╨╢╨╕╨╖╨╜╨╕ ╨┐╨╛╨╖╨╕╤Ж╨╕╨╕ ╤Б ╨┐╤А╨╛╨┤╨╗╨╡╨╜╨╕╨╡╨╝ ╨┤╨╗╤П ╨┐╤А╨╕╨▒╤Л╨╗╤М╨╜╤Л╤Е ╤Б╨┤╨╡╨╗╨╛╨║."""
        try:
            position = self._get_position(symbol)
            if not position:
                return

            entry_time = position.get("entry_time") or position.get("timestamp")
            if not entry_time:
                logger.debug(
                    f"тЪая╕П ╨Э╨╡╤В ╨▓╤А╨╡╨╝╨╡╨╜╨╕ ╨╛╤В╨║╤А╤Л╤В╨╕╤П ╨┤╨╗╤П ╨┐╨╛╨╖╨╕╤Ж╨╕╨╕ {symbol} "
                    f"(entry_time ╨▒╤Г╨┤╨╡╤В ╤Г╤Б╤В╨░╨╜╨╛╨▓╨╗╨╡╨╜ ╨┐╤А╨╕ ╨╕╨╜╨╕╤Ж╨╕╨░╨╗╨╕╨╖╨░╤Ж╨╕╨╕ TSL)"
                )
                return

            if isinstance(entry_time, datetime):
                # тЬЕ ╨Ш╨б╨Я╨а╨Р╨Т╨Ы╨Х╨Э╨Ш╨Х: ╨г╨▒╨╡╨╢╨┤╨░╨╡╨╝╤Б╤П, ╤З╤В╨╛ entry_time ╨▓ UTC
                if entry_time.tzinfo is None:
                    entry_time = entry_time.replace(tzinfo=timezone.utc)
                elif entry_time.tzinfo != timezone.utc:
                    entry_time = entry_time.astimezone(timezone.utc)
                time_held = (
                    datetime.now(timezone.utc) - entry_time
                ).total_seconds() / 60.0
            else:
                logger.debug(
                    f"тЪая╕П ╨Э╨╡╨▓╨╡╤А╨╜╤Л╨╣ ╤Д╨╛╤А╨╝╨░╤В entry_time ╨┤╨╗╤П {symbol}: {entry_time}"
                )
                return

            max_holding_minutes = 30.0
            extend_time_if_profitable = True
            min_profit_for_extension = 0.1
            extension_percent = 50.0

            try:
                if (
                    hasattr(self.signal_generator, "regime_manager")
                    and self.signal_generator.regime_manager
                ):
                    regime_obj = (
                        self.signal_generator.regime_manager.get_current_regime()
                        if not market_regime
                        else market_regime
                    )
                    if isinstance(regime_obj, str):
                        regime_obj = regime_obj.lower()

                    regime_params = (
                        self.signal_generator.regime_manager.get_current_parameters()
                    )
                    if regime_params:
                        max_holding_minutes = float(
                            getattr(regime_params, "max_holding_minutes", 30.0)
                        )

                    regime_name = (
                        regime_obj
                        if isinstance(regime_obj, str)
                        else getattr(regime_obj, "value", "ranging").lower()
                    )
                    adaptive_regime_cfg = getattr(
                        getattr(self.scalping_config, "adaptive_regime", None),
                        regime_name,
                        None,
                    )
                    if adaptive_regime_cfg:
                        extend_time_if_profitable = bool(
                            getattr(
                                adaptive_regime_cfg, "extend_time_if_profitable", True
                            )
                        )
                        min_profit_for_extension = float(
                            getattr(
                                adaptive_regime_cfg, "min_profit_for_extension", 0.1
                            )
                        )
                        extension_percent = float(
                            getattr(adaptive_regime_cfg, "extension_percent", 50.0)
                        )
            except Exception as e:
                logger.debug(
                    f"╨Э╨╡ ╤Г╨┤╨░╨╗╨╛╤Б╤М ╨┐╨╛╨╗╤Г╤З╨╕╤В╤М ╨┐╨░╤А╨░╨╝╨╡╤В╤А╤Л ╤А╨╡╨╢╨╕╨╝╨░: {e}, ╨╕╤Б╨┐╨╛╨╗╤М╨╖╤Г╨╡╨╝ fallback"
                )

            actual_max_holding = float(
                position.get("max_holding_minutes", max_holding_minutes)
            )

            if time_held >= actual_max_holding:
                time_extended = position.get("time_extended", False)
                # тЬЕ ╨Ш╨б╨Я╨а╨Р╨Т╨Ы╨Х╨Э╨Ю: ╨Я╤А╨╛╨▓╨╡╤А╤П╨╡╨╝ ╨┐╤А╨╛╨┤╨╗╨╡╨╜╨╕╨╡ ╨Т╨Р╨Ц╨Э╨Х╨Х ╤З╨╡╨╝ ╨╖╨░╨║╤А╤Л╤В╨╕╨╡
                if (
                    extend_time_if_profitable
                    and not time_extended
                    and profit_pct
                    >= min_profit_for_extension  # тЬЕ ╨Ш╨б╨Я╨а╨Р╨Т╨Ы╨Х╨Э╨Ю: >= ╨▓╨╝╨╡╤Б╤В╨╛ > (0.44% >= 0.5% = false, ╨╜╨╛ ╤Н╤В╨╛ ╨┐╤А╨░╨▓╨╕╨╗╤М╨╜╨╛, ╨╜╤Г╨╢╨╜╨╛ >= 0.5%)
                ):
                    original_max_holding = max_holding_minutes
                    extension_minutes = original_max_holding * (
                        extension_percent / 100.0
                    )
                    new_max_holding = original_max_holding + extension_minutes
                    position["time_extended"] = True
                    position["max_holding_minutes"] = new_max_holding
                    # тЬЕ ╨Ю╨▒╨╜╨╛╨▓╨╗╤П╨╡╨╝ ╤В╨░╨║╨╢╨╡ ╨▓ orchestrator.active_positions ╨┤╨╗╤П ╤Б╨╕╨╜╤Е╤А╨╛╨╜╨╕╨╖╨░╤Ж╨╕╨╕
                    if hasattr(self, "orchestrator") and self.orchestrator:
                        if symbol in self.orchestrator.active_positions:
                            self.orchestrator.active_positions[symbol][
                                "time_extended"
                            ] = True
                            self.orchestrator.active_positions[symbol][
                                "max_holding_minutes"
                            ] = new_max_holding
                    logger.info(
                        f"тЬЕ ╨Я╨╛╨╖╨╕╤Ж╨╕╤П {symbol} ╨▓ ╨┐╤А╨╕╨▒╤Л╨╗╨╕ {profit_pct:.2%} "
                        f"(>={min_profit_for_extension:.2%}), ╨┐╤А╨╛╨┤╨╗╨╡╨▓╨░╨╡╨╝ ╨▓╤А╨╡╨╝╤П ╨╜╨░ "
                        f"{extension_minutes:.1f} ╨╝╨╕╨╜╤Г╤В (╤Б {original_max_holding:.1f} ╨┤╨╛ {new_max_holding:.1f} ╨╝╨╕╨╜╤Г╤В)"
                    )
                    return

                # тЬЕ ╨Ш╨б╨Я╨а╨Р╨Т╨Ы╨Х╨Э╨Ю: ╨Э╨╡ ╨╖╨░╨║╤А╤Л╨▓╨░╨╡╨╝ ╨┐╨╛ max_holding ╨╡╤Б╨╗╨╕ ╨┐╤А╨╕╨▒╤Л╨╗╤М > min_profit_to_close
                # ╨С╨╛╤В ╨┐╤А╨╛╨┤╨╛╨╗╨╢╨░╨╡╤В ╨╕╤Б╨║╨░╤В╤М ╨╛╨┐╤В╨╕╨╝╨░╨╗╤М╨╜╤Л╨╣ ╨╝╨╛╨╝╨╡╨╜╤В ╨╖╨░╨║╤А╤Л╤В╨╕╤П ╤З╨╡╤А╨╡╨╖ TP/SL
                min_profit_to_close = None
                tsl = self.trailing_sl_by_symbol.get(symbol)
                if tsl:
                    min_profit_to_close = getattr(tsl, "min_profit_to_close", None)

                if (
                    min_profit_to_close is not None
                    and profit_pct >= min_profit_to_close
                ):
                    logger.info(
                        f"тЬЕ ╨Я╨╛╨╖╨╕╤Ж╨╕╤П {symbol} ╤Г╨┤╨╡╤А╨╢╨╕╨▓╨░╨╡╤В╤Б╤П {time_held:.1f} ╨╝╨╕╨╜╤Г╤В "
                        f"(╨╗╨╕╨╝╨╕╤В: {actual_max_holding:.1f} ╨╝╨╕╨╜╤Г╤В), "
                        f"╨┐╤А╨╕╨▒╤Л╨╗╤М {profit_pct:.2%} >= min_profit_to_close {min_profit_to_close:.2%}, "
                        f"╨╜╨╡ ╨╖╨░╨║╤А╤Л╨▓╨░╨╡╨╝ ╨┐╨╛ max_holding (╨▒╨╛╤В ╨┐╤А╨╛╨┤╨╛╨╗╨╢╨░╨╡╤В ╨╕╤Б╨║╨░╤В╤М ╨╛╨┐╤В╨╕╨╝╨░╨╗╤М╨╜╤Л╨╣ ╨╝╨╛╨╝╨╡╨╜╤В ╤З╨╡╤А╨╡╨╖ TP/SL)"
                    )
                    return

                # тЬЕ ╨Ш╨б╨Я╨а╨Р╨Т╨Ы╨Х╨Э╨Ю: ╨г╨▒╤Л╤В╨╛╤З╨╜╤Л╨╡ ╨┐╨╛╨╖╨╕╤Ж╨╕╨╕ ╨Э╨Х ╨╖╨░╨║╤А╤Л╨▓╨░╨╡╨╝ ╨┐╨╛ ╨▓╤А╨╡╨╝╨╡╨╜╨╕ (╨╢╨┤╨╡╨╝ TP/SL ╨╕╨╗╨╕ ╤А╨░╨╖╨▓╨╛╤А╨╛╤В╨░)
                if profit_pct <= 0:
                    logger.info(
                        f"тП░ ╨Я╨╛╨╖╨╕╤Ж╨╕╤П {symbol} ╤Г╨┤╨╡╤А╨╢╨╕╨▓╨░╨╡╤В╤Б╤П {time_held:.1f} ╨╝╨╕╨╜╤Г╤В "
                        f"(╨╗╨╕╨╝╨╕╤В: {actual_max_holding:.1f} ╨╝╨╕╨╜╤Г╤В), "
                        f"╨┐╤А╨╕╨▒╤Л╨╗╤М {profit_pct:.2%} <= 0%, ╨Э╨Х ╨╖╨░╨║╤А╤Л╨▓╨░╨╡╨╝ ╨┐╨╛ ╨▓╤А╨╡╨╝╨╡╨╜╨╕ (╨╢╨┤╨╡╨╝ TP/SL)"
                    )
                    return

                # тЬЕ ╨Ш╨б╨Я╨а╨Р╨Т╨Ы╨Х╨Э╨Ю: ╨Ч╨░╨║╤А╤Л╨▓╨░╨╡╨╝ ╨в╨Ю╨Ы╨м╨Ъ╨Ю ╨╡╤Б╨╗╨╕ ╨┐╤А╨╕╨▒╤Л╨╗╤М ╨╝╨░╨╗╨░ (< min_profit_for_extension) ╨Ш ╨▓╤А╨╡╨╝╤П ╨▓╤Л╤И╨╗╨╛
                if profit_pct < min_profit_for_extension:
                    logger.warning(
                        f"тП░ ╨Я╨╛╨╖╨╕╤Ж╨╕╤П {symbol} ╤Г╨┤╨╡╤А╨╢╨╕╨▓╨░╨╡╤В╤Б╤П {time_held:.1f} ╨╝╨╕╨╜╤Г╤В "
                        f"(╨╗╨╕╨╝╨╕╤В: {actual_max_holding:.1f} ╨╝╨╕╨╜╤Г╤В), "
                        f"╨┐╤А╨╕╨▒╤Л╨╗╤М {profit_pct:.2%} < {min_profit_for_extension:.2%} (min ╨┤╨╗╤П ╨┐╤А╨╛╨┤╨╗╨╡╨╜╨╕╤П), ╨╖╨░╨║╤А╤Л╨▓╨░╨╡╨╝ ╨┐╨╛ ╨▓╤А╨╡╨╝╨╡╨╜╨╕"
                    )
                    await self.close_position_callback(symbol, "max_holding_time")
                else:
                    # тЬЕ ╨Х╤Б╨╗╨╕ ╨┐╤А╨╕╨▒╤Л╨╗╤М >= min_profit_for_extension, ╨╜╨╛ ╨╜╨╡ ╨┐╤А╨╛╨┤╨╗╨╡╨▓╨░╨╡╨╝ (╨▓╨╛╨╖╨╝╨╛╨╢╨╜╨╛, ╤Г╨╢╨╡ ╨┐╤А╨╛╨┤╨╗╨╡╨╜╨░)
                    # ╨Ш╤Б╨┐╨╛╨╗╤М╨╖╤Г╨╡╨╝ trailing stop ╨▓╨╝╨╡╤Б╤В╨╛ ╨╖╨░╨║╤А╤Л╤В╨╕╤П ╨┐╨╛ ╨▓╤А╨╡╨╝╨╡╨╜╨╕
                    logger.info(
                        f"тЬЕ ╨Я╨╛╨╖╨╕╤Ж╨╕╤П {symbol} ╤Г╨┤╨╡╤А╨╢╨╕╨▓╨░╨╡╤В╤Б╤П {time_held:.1f} ╨╝╨╕╨╜╤Г╤В "
                        f"(╨╗╨╕╨╝╨╕╤В: {actual_max_holding:.1f} ╨╝╨╕╨╜╤Г╤В), "
                        f"╨┐╤А╨╕╨▒╤Л╨╗╤М {profit_pct:.2%} >= {min_profit_for_extension:.2%}, ╨Э╨Х ╨╖╨░╨║╤А╤Л╨▓╨░╨╡╨╝ (╨╕╤Б╨┐╨╛╨╗╤М╨╖╤Г╨╡╨╝ trailing stop)"
                    )
                    return

        except Exception as e:
            logger.error(f"╨Ю╤И╨╕╨▒╨║╨░ ╨┐╤А╨╛╨▓╨╡╤А╨║╨╕ ╨▓╤А╨╡╨╝╨╡╨╜╨╕ ╨╢╨╕╨╖╨╜╨╕ ╨┐╨╛╨╖╨╕╤Ж╨╕╨╕ {symbol}: {e}")

    def get_tsl(self, symbol: str) -> Optional[TrailingStopLoss]:
        """╨Т╨╛╨╖╨▓╤А╨░╤Й╨░╨╡╤В TSL ╨┤╨╗╤П ╤Б╨╕╨╝╨▓╨╛╨╗╨░."""
        return self.trailing_sl_by_symbol.get(symbol)

    def remove_tsl(self, symbol: str) -> Optional[TrailingStopLoss]:
        """╨г╨┤╨░╨╗╤П╨╡╤В TSL ╨┤╨╗╤П ╤Б╨╕╨╝╨▓╨╛╨╗╨░ ╨╕ ╨▓╨╛╨╖╨▓╤А╨░╤Й╨░╨╡╤В ╨╡╨│╨╛."""
        tsl = self.trailing_sl_by_symbol.pop(symbol, None)
        if tsl:
            logger.debug(f"тЬЕ TSL ╤Г╨┤╨░╨╗╨╡╨╜ ╨┤╨╗╤П {symbol}")
        return tsl

    def clear_all_tsl(self) -> int:
        """╨Ю╤З╨╕╤Й╨░╨╡╤В ╨▓╤Б╨╡ TSL ╨╕ ╨▓╨╛╨╖╨▓╤А╨░╤Й╨░╨╡╤В ╨║╨╛╨╗╨╕╤З╨╡╤Б╤В╨▓╨╛ ╤Г╨┤╨░╨╗╨╡╨╜╨╜╤Л╤Е ╨╖╨░╨┐╨╕╤Б╨╡╨╣."""
        count = len(self.trailing_sl_by_symbol)
        self.trailing_sl_by_symbol.clear()
        logger.info(f"тЬЕ ╨Ю╤З╨╕╤Й╨╡╨╜╨╛ {count} TSL")
        return count
