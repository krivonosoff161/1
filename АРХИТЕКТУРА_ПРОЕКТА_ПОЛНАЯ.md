# 🏗️ ПОЛНАЯ АРХИТЕКТУРА ТОРГОВОГО БОТА OKX

## 📋 ОГЛАВЛЕНИЕ
1. [Обзор архитектуры](#обзор-архитектуры)
2. [Структура файлов](#структура-файлов)
3. [Точки входа](#точки-входа)
4. [Конфигурация](#конфигурация)
5. [Клиенты API](#клиенты-api)
6. [Стратегии](#стратегии)
7. [Модули](#модули)
8. [Потоки данных](#потоки-данных)
9. [Логирование](#логирование)
10. [Тестирование](#тестирование)

---

## 🎯 ОБЗОР АРХИТЕКТУРЫ

### Двухрежимная архитектура
```
┌─────────────────────────────────────────────────────────────┐
│                    TRADING BOT OKX                          │
├─────────────────────────────────────────────────────────────┤
│  🚀 LAUNCHER (run.py)                                       │
│  ├── Spot Mode    → src/main_spot.py                        │
│  └── Futures Mode → src/main_futures.py                     │
├─────────────────────────────────────────────────────────────┤
│  📁 SHARED COMPONENTS                                       │
│  ├── Config Management (src/config.py)                      │
│  ├── Models (src/models.py)                                │
│  ├── Indicators (src/indicators/)                           │
│  └── Utils (src/utils/)                                     │
├─────────────────────────────────────────────────────────────┤
│  📁 SPOT STRATEGY                                           │
│  ├── Orchestrator (src/strategies/scalping/spot/)           │
│  ├── Signal Generator                                       │
│  ├── Order Executor                                         │
│  ├── Position Manager                                       │
│  └── Performance Tracker                                   │
├─────────────────────────────────────────────────────────────┤
│  📁 FUTURES STRATEGY                                       │
│  ├── Orchestrator (src/strategies/scalping/futures/)       │
│  ├── Signal Generator                                       │
│  ├── Order Executor                                         │
│  ├── Position Manager                                       │
│  ├── Margin Calculator                                      │
│  ├── Liquidation Guard                                      │
│  └── Slippage Guard                                         │
└─────────────────────────────────────────────────────────────┘
```

---

## 📁 СТРУКТУРА ФАЙЛОВ

### Корневая структура
```
simple-trading-bot-okx/
├── 📁 config/                    # Конфигурационные файлы
│   ├── config_spot.yaml         # Настройки Spot торговли
│   ├── config_futures.yaml      # Настройки Futures торговли
│   ├── manual_pools.yaml        # Ручные пулы параметров
│   └── features.yaml            # Функциональные настройки
├── 📁 src/                      # Исходный код
│   ├── main_spot.py             # Точка входа Spot
│   ├── main_futures.py          # Точка входа Futures
│   ├── config.py                # Управление конфигурацией
│   ├── models.py                # Модели данных
│   ├── 📁 clients/              # API клиенты
│   ├── 📁 strategies/           # Торговые стратегии
│   ├── 📁 indicators/           # Технические индикаторы
│   ├── 📁 filters/              # Фильтры сигналов
│   ├── 📁 risk/                 # Управление рисками
│   ├── 📁 balance/              # Управление балансом
│   └── 📁 utils/                # Утилиты
├── 📁 tests/                    # Тесты
├── 📁 logs/                     # Логи
├── 📁 data/                     # Данные
├── run.py                       # CLI Launcher
├── start.bat                    # Windows Launcher
└── requirements.txt             # Зависимости
```

### Детальная структура src/
```
src/
├── 📁 clients/                  # API клиенты
│   ├── spot_client.py          # OKX Spot API
│   ├── futures_client.py       # OKX Futures API
│   └── __init__.py
├── 📁 strategies/               # Торговые стратегии
│   ├── 📁 scalping/           # Скальпинг стратегии
│   │   ├── 📁 spot/           # Spot скальпинг
│   │   │   ├── orchestrator.py        # Главный координатор
│   │   │   ├── signal_generator.py   # Генератор сигналов
│   │   │   ├── order_executor.py     # Исполнитель ордеров
│   │   │   ├── position_manager.py  # Менеджер позиций
│   │   │   ├── performance_tracker.py # Трекер производительности
│   │   │   └── websocket_orchestrator.py # WebSocket координатор
│   │   └── 📁 futures/        # Futures скальпинг
│   │       ├── orchestrator.py        # Futures координатор
│   │       ├── signal_generator.py    # Futures сигналы
│   │       ├── order_executor.py      # Futures ордера
│   │       └── position_manager.py   # Futures позиции
│   └── 📁 modules/            # Общие модули
│       ├── adaptive_regime_manager.py    # Адаптивный режим
│       ├── balance_checker.py           # Проверка баланса
│       ├── correlation_filter.py        # Корреляционный фильтр
│       ├── liquidation_guard.py         # Защита от ликвидации
│       ├── margin_calculator.py         # Калькулятор маржи
│       ├── multi_timeframe.py           # Мультитаймфрейм
│       ├── pivot_points.py              # Пивотные точки
│       ├── slippage_guard.py            # Защита от проскальзывания
│       └── volume_profile_filter.py    # Фильтр объемного профиля
├── 📁 indicators/             # Технические индикаторы
│   ├── base.py                # Базовый класс индикаторов
│   ├── 📁 advanced/           # Продвинутые индикаторы
│   │   ├── pivot_calculator.py
│   │   └── volume_profile.py
│   └── __init__.py
├── 📁 filters/               # Фильтры сигналов
│   ├── correlation_manager.py
│   ├── time_session_manager.py
│   └── __init__.py
├── 📁 risk/                  # Управление рисками
│   ├── risk_controller.py
│   ├── risk_controller_config.py
│   └── __init__.py
├── 📁 balance/               # Управление балансом
│   ├── adaptive_balance_manager.py
│   └── __init__.py
└── 📁 utils/                 # Утилиты
    ├── logging_setup.py
    ├── telegram_notifier.py
    └── __init__.py
```

---

## 🚀 ТОЧКИ ВХОДА

### 1. CLI Launcher (run.py)
```python
# Основные команды:
python run.py --mode spot          # Запуск Spot бота
python run.py --mode futures       # Запуск Futures бота
python run.py --interactive        # Интерактивный режим
python run.py --check-config       # Проверка конфигурации
```

### 2. Прямые точки входа
```python
# Spot торговля
python src/main_spot.py

# Futures торговля  
python src/main_futures.py
```

### 3. Windows Batch Launcher
```batch
# start.bat - интерактивный выбор режима
start.bat
```

---

## ⚙️ КОНФИГУРАЦИЯ

### Структура конфигурации
```yaml
# config/config_spot.yaml
api:
  okx:
    api_key: "your_api_key"
    api_secret: "your_api_secret"
    passphrase: "your_passphrase"
    sandbox: true

trading:
  symbols: ["BTC-USDT", "ETH-USDT"]
  base_currency: "USDT"

risk:
  max_position_size_percent: 5.0
  max_daily_loss_percent: 10.0
  risk_per_trade_percent: 1.0
  max_open_positions: 3
  adaptive_minimums:
    small:
      balance_threshold: 1500.0
      minimum_order_usd: 10.0
    medium:
      balance_threshold: 2300.0
      minimum_order_usd: 15.0
    large:
      balance_threshold: 999999.0
      minimum_order_usd: 20.0

scalping:
  enabled: true
  symbols: ["BTC-USDT", "ETH-USDT"]
  timeframe: "1m"
  indicators:
    sma_fast: 5
    sma_slow: 20
    ema_fast: 8
    ema_slow: 21
    rsi_period: 14
    atr_period: 14
  entry:
    min_volatility_atr: 0.0005
    rsi_overbought: 70
    rsi_oversold: 30
    volume_threshold: 1.2
  exit:
    take_profit_atr_multiplier: 2.0
    stop_loss_atr_multiplier: 1.5
    max_holding_minutes: 15

manual_pools: {}
```

### Загрузка конфигурации
```python
# src/config.py
class BotConfig(BaseModel):
    api: Dict[str, APIConfig]
    trading: TradingConfig
    risk: RiskConfig
    scalping: ScalpingConfig
    manual_pools: Optional[Dict] = Field(default_factory=dict)

    @classmethod
    def load_from_file(cls, config_path: str) -> "BotConfig":
        # Загрузка и валидация YAML конфигурации
```

---

## 🔌 КЛИЕНТЫ API

### Spot Client (src/clients/spot_client.py)
```python
class OKXClient:
    """OKX Spot API клиент"""
    
    async def get_balance(self) -> float
    async def place_order(self, symbol: str, side: str, size: float, price: float) -> dict
    async def place_oco_order(self, symbol: str, side: str, size: float, tp_price: float, sl_price: float) -> dict
    async def cancel_order(self, symbol: str, order_id: str) -> dict
    async def get_positions(self) -> list
    async def get_ticker(self, symbol: str) -> dict
```

### Futures Client (src/clients/futures_client.py)
```python
class OKXFuturesClient:
    """OKX Futures API клиент"""
    
    async def get_balance(self) -> float
    async def get_margin_info(self, symbol: str) -> dict
    async def set_leverage(self, symbol: str, leverage: int) -> dict
    async def place_futures_order(self, symbol: str, side: str, size: float, price: float) -> dict
    async def place_oco_order(self, symbol: str, side: str, size: float, tp_price: float, sl_price: float) -> dict
    async def get_positions(self, symbol: Optional[str] = None) -> list
    async def batch_amend_orders(self, amend_list: list) -> dict
```

---

## 📈 СТРАТЕГИИ

### Spot Strategy (src/strategies/scalping/spot/)

#### Orchestrator (orchestrator.py)
```python
class ScalpingOrchestrator:
    """Главный координатор Spot стратегии"""
    
    def __init__(self, config: BotConfig):
        self.client = OKXClient(config.get_okx_config())
        self.signal_generator = SignalGenerator(config.scalping)
        self.order_executor = OrderExecutor(config.scalping)
        self.position_manager = PositionManager(config.scalping)
        self.performance_tracker = PerformanceTracker()
        
        # Phase 1 модули
        self.mtf_filter = MultiTimeframeFilter(config.scalping.multi_timeframe)
        self.correlation_filter = CorrelationFilter(config.scalping.correlation_filter)
        self.adx_filter = ADXFilter(config.scalping.adx_filter)
        self.time_filter = TimeSessionManager(config.scalping.time_filter)
        self.pivot_filter = PivotPointsFilter(config.scalping.pivot_points)
        self.volume_profile_filter = VolumeProfileFilter(config.scalping.volume_profile)
        self.balance_checker = BalanceChecker(config.scalping.balance_checker)
        self.adaptive_regime = AdaptiveRegimeManager(config.scalping.adaptive_regime)
    
    async def start(self):
        """Запуск торгового цикла"""
        while True:
            # 1. Получение рыночных данных
            market_data = await self.client.get_ticker(self.symbol)
            
            # 2. Генерация сигналов
            signals = await self.signal_generator.generate_signals(market_data)
            
            # 3. Фильтрация сигналов через модули
            filtered_signals = await self._apply_filters(signals, market_data)
            
            # 4. Исполнение ордеров
            if filtered_signals:
                await self.order_executor.execute_orders(filtered_signals)
            
            # 5. Управление позициями
            await self.position_manager.manage_positions()
            
            # 6. Обновление статистики
            await self.performance_tracker.update_stats()
            
            await asyncio.sleep(1)
```

#### Signal Generator (signal_generator.py)
```python
class SignalGenerator:
    """Генератор торговых сигналов для Spot"""
    
    async def generate_signals(self, market_data: MarketData) -> List[Signal]:
        """Генерация сигналов на основе технических индикаторов"""
        
        # 1. Расчет индикаторов
        sma_fast = self._calculate_sma(market_data.close_prices, self.config.indicators.sma_fast)
        sma_slow = self._calculate_sma(market_data.close_prices, self.config.indicators.sma_slow)
        rsi = self._calculate_rsi(market_data.close_prices, self.config.indicators.rsi_period)
        atr = self._calculate_atr(market_data.high_prices, market_data.low_prices, market_data.close_prices)
        
        # 2. Генерация сигналов
        signals = []
        
        # Long сигнал
        if (sma_fast > sma_slow and 
            rsi < self.config.entry.rsi_oversold and
            atr > self.config.entry.min_volatility_atr):
            signals.append(Signal(
                symbol=market_data.symbol,
                side="buy",
                entry_price=market_data.last_price,
                tp_price=market_data.last_price * (1 + self.config.exit.take_profit_atr_multiplier * atr),
                sl_price=market_data.last_price * (1 - self.config.exit.stop_loss_atr_multiplier * atr)
            ))
        
        return signals
```

#### Order Executor (order_executor.py)
```python
class OrderExecutor:
    """Исполнитель ордеров для Spot"""
    
    async def execute_orders(self, signals: List[Signal]):
        """Исполнение торговых ордеров"""
        
        for signal in signals:
            try:
                # 1. Проверка баланса
                if not await self.balance_checker.check_balance(signal):
                    continue
                
                # 2. Размещение OCO ордера
                order_result = await self.client.place_oco_order(
                    symbol=signal.symbol,
                    side=signal.side,
                    size=signal.size,
                    tp_price=signal.tp_price,
                    sl_price=signal.sl_price
                )
                
                # 3. Сохранение ордера
                await self.position_manager.add_position(signal, order_result)
                
            except Exception as e:
                logger.error(f"Ошибка исполнения ордера: {e}")
```

### Futures Strategy (src/strategies/scalping/futures/)

#### Orchestrator (orchestrator.py)
```python
class FuturesScalpingOrchestrator:
    """Главный координатор Futures стратегии"""
    
    def __init__(self, config: BotConfig):
        self.client = OKXFuturesClient(config.get_okx_config())
        self.signal_generator = FuturesSignalGenerator(config.scalping)
        self.order_executor = FuturesOrderExecutor(config.scalping)
        self.position_manager = FuturesPositionManager(config.scalping)
        
        # Futures-специфичные модули
        self.margin_calculator = MarginCalculator(leverage=3)
        self.liquidation_guard = LiquidationGuard()
        self.slippage_guard = SlippageGuard()
    
    async def start(self):
        """Запуск Futures торгового цикла"""
        while True:
            # 1. Проверка маржи
            await self.liquidation_guard.check_margin_health(self.client, self.position_manager)
            
            # 2. Получение рыночных данных
            market_data = await self.client.get_ticker(self.symbol)
            
            # 3. Генерация сигналов
            signals = await self.signal_generator.generate_signals(market_data)
            
            # 4. Проверка проскальзывания
            filtered_signals = []
            for signal in signals:
                if await self.slippage_guard.check_slippage_before_order(self.client, signal.symbol, signal.entry_price, signal.side):
                    filtered_signals.append(signal)
            
            # 5. Исполнение ордеров
            if filtered_signals:
                await self.order_executor.execute_orders(filtered_signals)
            
            # 6. Управление позициями
            await self.position_manager.manage_positions()
            
            await asyncio.sleep(0.5)  # Более частые проверки для Futures
```

---

## 🧩 МОДУЛИ

### Адаптивный режим (adaptive_regime_manager.py)
```python
class AdaptiveRegimeManager:
    """Адаптивный менеджер режимов рынка"""
    
    def __init__(self, config: RegimeConfig):
        self.volatility_thresholds = config.volatility_thresholds
        self.balance_thresholds = config.balance_thresholds
        self.adx_thresholds = config.adx_thresholds
    
    async def determine_regime(self, market_data: MarketData, balance: float) -> Regime:
        """Определение текущего режима рынка"""
        
        # 1. Анализ волатильности
        volatility = self._calculate_volatility(market_data)
        
        # 2. Анализ тренда (ADX)
        adx = self._calculate_adx(market_data)
        
        # 3. Анализ баланса
        balance_regime = self._determine_balance_regime(balance)
        
        # 4. Определение режима
        if volatility < self.volatility_thresholds.low and adx < self.adx_thresholds.weak:
            return Regime.FLAT
        elif volatility > self.volatility_thresholds.high and adx > self.adx_thresholds.strong:
            return Regime.TRENDING
        else:
            return Regime.SIDEWAYS
    
    def get_adaptive_parameters(self, regime: Regime, balance_regime: str) -> AdaptiveParameters:
        """Получение адаптивных параметров"""
        
        if regime == Regime.FLAT:
            return AdaptiveParameters(
                tp_multiplier=0.8,  # Меньший TP для флэта
                sl_multiplier=0.6,  # Меньший SL для флэта
                position_size_multiplier=0.7
            )
        elif regime == Regime.TRENDING:
            return AdaptiveParameters(
                tp_multiplier=1.5,  # Больший TP для тренда
                sl_multiplier=1.2,  # Больший SL для тренда
                position_size_multiplier=1.0
            )
```

### Проверка баланса (balance_checker.py)
```python
class BalanceChecker:
    """Проверка баланса перед открытием позиций"""
    
    def __init__(self, config: BalanceCheckConfig):
        self.config = config
        self.adaptive_minimums = config.adaptive_minimums
    
    async def check_balance(self, signal: Signal) -> bool:
        """Проверка достаточности баланса"""
        
        # 1. Получение текущего баланса
        balance = await self.client.get_balance()
        
        # 2. Определение адаптивного минимума
        adaptive_minimum = self._get_adaptive_minimum(balance)
        
        # 3. Проверка USDT баланса для LONG
        if signal.side == "buy":
            required_usdt = signal.size * signal.entry_price
            if balance.free_usdt < required_usdt + adaptive_minimum:
                logger.warning(f"Недостаточно USDT: {balance.free_usdt} < {required_usdt + adaptive_minimum}")
                return False
        
        # 4. Проверка актива для SHORT
        elif signal.side == "sell":
            if balance.free_asset < signal.size:
                logger.warning(f"Недостаточно актива: {balance.free_asset} < {signal.size}")
                return False
        
        return True
    
    def _get_adaptive_minimum(self, total_balance_usd: float) -> float:
        """Определение адаптивного минимума на основе баланса"""
        
        if self.adaptive_minimums:
            if total_balance_usd <= self.adaptive_minimums["small"]["balance_threshold"]:
                return self.adaptive_minimums["small"]["minimum_order_usd"]
            elif total_balance_usd <= self.adaptive_minimums["medium"]["balance_threshold"]:
                return self.adaptive_minimums["medium"]["minimum_order_usd"]
            else:
                return self.adaptive_minimums["large"]["minimum_order_usd"]
        
        # Fallback значения
        if total_balance_usd <= 1500:
            return 10.0
        elif total_balance_usd <= 2300:
            return 15.0
        else:
            return 20.0
```

### Калькулятор маржи (margin_calculator.py)
```python
class MarginCalculator:
    """Калькулятор маржи для Futures"""
    
    def __init__(self, leverage=3, safety_buffer=0.01, maintenance_margin_rate=0.005, initial_margin_rate=0.01):
        self.leverage = leverage
        self.safety_buffer = safety_buffer
        self.maintenance_margin_rate = maintenance_margin_rate
        self.initial_margin_rate = initial_margin_rate
    
    def calculate_max_safe_size(self, balance_usd: float, entry_price: float, sl_percent: float) -> float:
        """Расчет максимального безопасного размера позиции"""
        
        # 1. Расчет доступной маржи
        available_margin = balance_usd * (1 - self.safety_buffer)
        
        # 2. Расчет максимального номинала
        max_notional = available_margin * self.leverage
        
        # 3. Расчет размера позиции
        max_size = max_notional / entry_price
        
        # 4. Учет стоп-лосса
        sl_distance = sl_percent * entry_price
        max_safe_size = max_size * (1 - sl_percent)
        
        return max_safe_size
    
    def calculate_liquidation_price(self, entry_price: float, position_side: str, leverage: Optional[int] = None) -> float:
        """Расчет цены ликвидации"""
        
        leverage = leverage or self.leverage
        
        if position_side == "long":
            # Для лонга: liq_price = entry_price * (1 - (1/leverage) + maintenance_margin)
            liq_price = entry_price * (1 - (1/leverage) + self.maintenance_margin_rate)
        else:
            # Для шорта: liq_price = entry_price * (1 + (1/leverage) - maintenance_margin)
            liq_price = entry_price * (1 + (1/leverage) - self.maintenance_margin_rate)
        
        return liq_price
```

### Защита от ликвидации (liquidation_guard.py)
```python
class LiquidationGuard:
    """Защита от ликвидации позиций"""
    
    def __init__(self, warning_threshold=1.8, danger_threshold=1.3, critical_threshold=1.1, auto_close_threshold=1.1, auto_close_percent=0.5):
        self.warning_threshold = warning_threshold
        self.danger_threshold = danger_threshold
        self.critical_threshold = critical_threshold
        self.auto_close_threshold = auto_close_threshold
        self.auto_close_percent = auto_close_percent
    
    async def check_margin_health(self, client, position_manager):
        """Проверка здоровья маржи"""
        
        # 1. Получение информации о марже
        margin_info = await client.get_margin_info()
        margin_ratio = margin_info.get("mgnRatio", 0)
        
        # 2. Проверка порогов
        if margin_ratio <= self.critical_threshold:
            await self._handle_critical_margin(margin_ratio, position_manager)
        elif margin_ratio <= self.danger_threshold:
            await self._handle_danger_margin(margin_ratio, position_manager)
        elif margin_ratio <= self.warning_threshold:
            await self._handle_warning_margin(margin_ratio, position_manager)
    
    async def _handle_critical_margin(self, margin_ratio, position_manager):
        """Обработка критического уровня маржи"""
        
        logger.critical(f"🚨 КРИТИЧЕСКИЙ УРОВЕНЬ МАРЖИ: {margin_ratio}")
        
        # Автоматическое закрытие части позиций
        if margin_ratio <= self.auto_close_threshold:
            logger.critical("🛑 АВТОМАТИЧЕСКОЕ ЗАКРЫТИЕ ПОЗИЦИЙ!")
            await position_manager.close_positions_percent(self.auto_close_percent)
```

### Защита от проскальзывания (slippage_guard.py)
```python
class SlippageGuard:
    """Защита от проскальзывания"""
    
    def __init__(self, max_slippage_percent=0.1, max_spread_percent=0.05, price_fetch_timeout=30.0):
        self.max_slippage_percent = max_slippage_percent
        self.max_spread_percent = max_spread_percent
        self.price_fetch_timeout = price_fetch_timeout
    
    async def check_slippage_before_order(self, client, symbol, order_price, order_side):
        """Проверка проскальзывания перед ордером"""
        
        # 1. Получение текущей цены
        current_price = await self.get_current_price(client, symbol)
        
        # 2. Расчет проскальзывания
        if order_side == "buy":
            slippage = (order_price - current_price.ask) / current_price.ask
        else:
            slippage = (current_price.bid - order_price) / current_price.bid
        
        # 3. Проверка спреда
        spread = (current_price.ask - current_price.bid) / current_price.mid
        
        # 4. Принятие решения
        if slippage > self.max_slippage_percent:
            logger.warning(f"Проскальзывание слишком большое: {slippage:.4f}")
            return False
        
        if spread > self.max_spread_percent:
            logger.warning(f"Спред слишком большой: {spread:.4f}")
            return False
        
        return True
```

---

## 📊 ПОТОКИ ДАННЫХ

### Spot Trading Flow
```
1. Market Data → Signal Generator → Filters → Order Executor → Position Manager
2. Position Manager → Performance Tracker → Statistics
3. Risk Controller → Position Manager (risk limits)
4. Balance Checker → Order Executor (balance validation)
```

### Futures Trading Flow
```
1. Market Data → Signal Generator → Filters → Order Executor → Position Manager
2. Margin Calculator → Position Manager (position sizing)
3. Liquidation Guard → Position Manager (margin monitoring)
4. Slippage Guard → Order Executor (slippage protection)
5. Position Manager → Performance Tracker → Statistics
```

### WebSocket Data Flow
```
WebSocket Manager → Market Data → Signal Generator
                → Account Updates → Position Manager
                → Order Updates → Order Executor
```

---

## 📝 ЛОГИРОВАНИЕ

### Структура логов
```
logs/
├── 📁 spot/                   # Логи Spot торговли
│   ├── spot_main.log         # Основной лог Spot
│   ├── trades_2025-10-26.csv # История сделок
│   └── performance.log       # Статистика производительности
├── 📁 futures/               # Логи Futures торговли
│   ├── futures_main.log      # Основной лог Futures
│   ├── trades_2025-10-26.csv # История сделок
│   └── margin_monitor.log    # Мониторинг маржи
└── 📁 extracted/             # Извлеченные логи
```

### Уровни логирования
```python
# Настройка логирования
logger.remove()
logger.add(
    sys.stdout,
    level="INFO",
    format="<green>{time:YYYY-MM-DD HH:mm:ss}</green> | <level>{level: <8}</level> | <cyan>{name}</cyan>:<cyan>{function}</cyan>:<cyan>{line}</cyan> - <level>{message}</level>",
)

# Файловое логирование
logger.add(
    "logs/spot/spot_main.log",
    level="DEBUG",
    format="{time:YYYY-MM-DD HH:mm:ss} | {level: <8} | {name}:{function}:{line} - {message}",
    rotation="10 MB",
    retention="7 days",
    compression="zip",
)
```

---

## 🧪 ТЕСТИРОВАНИЕ

### Структура тестов
```
tests/
├── 📁 unit/                  # Юнит тесты
│   ├── test_balance_checker.py
│   ├── test_margin_calculator.py
│   └── test_adaptive_regime.py
├── 📁 integration/           # Интеграционные тесты
│   ├── test_spot_integration.py
│   ├── test_futures_integration.py
│   └── test_api_clients.py
├── 📁 futures/              # Тесты Futures
│   ├── test_futures_client.py
│   ├── test_margin_calculator.py
│   └── test_integration.py
├── 📁 spot/                 # Тесты Spot
│   ├── test_spot_client.py
│   └── test_spot_strategy.py
└── 📁 debug/               # Отладочные тесты
    ├── quick_balance.py
    └── calc_total.py
```

### Запуск тестов
```bash
# Все тесты
python -m pytest tests/

# Конкретная категория
python -m pytest tests/unit/
python -m pytest tests/integration/
python -m pytest tests/futures/

# Конкретный тест
python -m pytest tests/unit/test_balance_checker.py
```

---

## 🔧 КОМАНДЫ ЗАПУСКА

### Основные команды
```bash
# Интерактивный запуск
python run.py

# Прямой запуск Spot
python run.py --mode spot
python src/main_spot.py

# Прямой запуск Futures
python run.py --mode futures
python src/main_futures.py

# Проверка конфигурации
python run.py --check-config

# Windows запуск
start.bat
```

### Отладочные команды
```bash
# Проверка баланса
python tests/debug/quick_balance.py

# Расчет общей суммы
python tests/debug/calc_total.py

# Тест API клиентов
python tests/integration/test_api_clients.py
```

---

## 📋 КЛЮЧЕВЫЕ ОСОБЕННОСТИ

### 1. Двухрежимная архитектура
- **Spot**: Консервативная торговля без левериджа
- **Futures**: Агрессивная торговля с левериджем 3x

### 2. Адаптивные параметры
- Автоматическая подстройка TP/SL под режим рынка
- Адаптивные размеры позиций по балансу
- Динамические минимумы ордеров

### 3. Модульная архитектура
- Независимые модули для каждой функции
- Легкое добавление новых фильтров
- Переиспользование кода между режимами

### 4. Безопасность Futures
- Калькулятор маржи
- Защита от ликвидации
- Защита от проскальзывания

### 5. Гибкая конфигурация
- YAML конфигурация для каждого режима
- Переменные окружения
- Валидация через Pydantic

---

## 🚨 ВАЖНЫЕ ЗАМЕЧАНИЯ

### Для Spot торговли:
- Минимальный ордер: $10
- Комиссия: 0.08% (maker)
- Без риска ликвидации
- Подходит для начинающих

### Для Futures торговли:
- Минимальный ордер: $5 (может быть меньше)
- Комиссия: 0.02% (maker)
- Леверидж: 3x
- Высокий риск ликвидации
- Требует опыт

### Безопасность:
- Всегда тестируйте в sandbox режиме
- Начинайте с минимальных сумм
- Настройте правильные пороги маржи
- Мониторьте логи постоянно

---

## 📞 ПОДДЕРЖКА

При возникновении проблем:
1. Проверьте логи в `logs/`
2. Запустите тесты: `python run.py --check-config`
3. Проверьте конфигурацию API ключей
4. Убедитесь в наличии достаточного баланса

---

*Документация обновлена: 26.10.2025*
*Версия архитектуры: 2.0*
