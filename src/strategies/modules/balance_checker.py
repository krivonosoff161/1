"""
Balance Checker Module - –ø—Ä–æ–≤–µ—Ä–∫–∞ –±–∞–ª–∞–Ω—Å–∞ –ø–µ—Ä–µ–¥ –æ—Ç–∫—Ä—ã—Ç–∏–µ–º –ø–æ–∑–∏—Ü–∏–π.

–ü—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ—Ç –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–µ –∑–∞–π–º—ã –≤ SPOT —Ä–µ–∂–∏–º–µ, –ø—Ä–æ–≤–µ—Ä—è—è –Ω–∞–ª–∏—á–∏–µ
–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ–≥–æ –±–∞–ª–∞–Ω—Å–∞ –¥–ª—è –æ—Ç–∫—Ä—ã—Ç–∏—è LONG (USDT) –∏ SHORT (–∞–∫—Ç–∏–≤) –ø–æ–∑–∏—Ü–∏–π.
"""

from dataclasses import dataclass
from typing import Dict, Optional

from loguru import logger

from src.models import Balance, OrderSide


@dataclass
class BalanceCheckConfig:
    """–ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –º–æ–¥—É–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –±–∞–ª–∞–Ω—Å–∞."""

    enabled: bool = True
    # –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π —Ä–µ–∑–µ—Ä–≤ USDT (–ø—Ä–æ—Ü–µ–Ω—Ç –æ—Ç –±–∞–ª–∞–Ω—Å–∞, –∫–æ—Ç–æ—Ä—ã–π –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è)
    usdt_reserve_percent: float = 10.0
    # –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –±–∞–ª–∞–Ω—Å –∞–∫—Ç–∏–≤–∞ –¥–ª—è –æ—Ç–∫—Ä—ã—Ç–∏—è SHORT (–≤ USD —ç–∫–≤–∏–≤–∞–ª–µ–Ω—Ç–µ)
    min_asset_balance_usd: float = 10.0
    # –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –±–∞–ª–∞–Ω—Å USDT –¥–ª—è –æ—Ç–∫—Ä—ã—Ç–∏—è LONG
    min_usdt_balance: float = 10.0
    # –õ–æ–≥–∏—Ä–æ–≤–∞—Ç—å –∫–∞–∂–¥—É—é –ø—Ä–æ–≤–µ—Ä–∫—É (–ø–æ–ª–µ–∑–Ω–æ –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏)
    log_all_checks: bool = False
    # –ê–¥–∞–ø—Ç–∏–≤–Ω—ã–µ –º–∏–Ω–∏–º—É–º—ã (–∏–∑ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏)
    adaptive_minimums: Optional[Dict] = None

    @classmethod
    def from_bot_config(cls, bot_config) -> "BalanceCheckConfig":
        """
        –°–æ–∑–¥–∞–µ—Ç BalanceCheckConfig –∏–∑ BotConfig.

        Args:
            bot_config: –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –±–æ—Ç–∞

        Returns:
            BalanceCheckConfig: –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –¥–ª—è BalanceChecker
        """
        # –ü–æ–ª—É—á–∞–µ–º –∞–¥–∞–ø—Ç–∏–≤–Ω—ã–µ –º–∏–Ω–∏–º—É–º—ã –∏–∑ risk —Å–µ–∫—Ü–∏–∏
        adaptive_minimums = None
        if hasattr(bot_config.risk, "adaptive_minimums"):
            adaptive_minimums = bot_config.risk.adaptive_minimums

        return cls(
            enabled=True,
            usdt_reserve_percent=10.0,
            min_asset_balance_usd=10.0,
            min_usdt_balance=10.0,
            log_all_checks=False,
            adaptive_minimums=adaptive_minimums,
        )


@dataclass
class BalanceCheckResult:
    """–†–µ–∑—É–ª—å—Ç–∞—Ç –ø—Ä–æ–≤–µ—Ä–∫–∏ –±–∞–ª–∞–Ω—Å–∞."""

    allowed: bool
    reason: str
    available_balance: float
    required_balance: float
    currency: str


class BalanceChecker:
    """
    –ü—Ä–æ–≤–µ—Ä—è–µ—Ç –±–∞–ª–∞–Ω—Å –ø–µ—Ä–µ–¥ –æ—Ç–∫—Ä—ã—Ç–∏–µ–º –ø–æ–∑–∏—Ü–∏–π.

    –ü—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ—Ç:
    - –û—Ç–∫—Ä—ã—Ç–∏–µ LONG –±–µ–∑ –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ–≥–æ USDT
    - –û—Ç–∫—Ä—ã—Ç–∏–µ SHORT –±–µ–∑ –∞–∫—Ç–∏–≤–∞ –Ω–∞ –±–∞–ª–∞–Ω—Å–µ
    - –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–µ –∑–∞–π–º—ã –≤ SPOT —Ä–µ–∂–∏–º–µ
    """

    def __init__(self, config: BalanceCheckConfig):
        self.config = config
        # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø—Ä–æ–ø—É—â–µ–Ω–Ω—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤
        self.blocked_signals: Dict[str, int] = {}
        self.total_checks = 0
        self.total_blocked = 0

        logger.info(
            f"Balance Checker initialized: "
            f"USDT reserve={config.usdt_reserve_percent}%, "
            f"min_asset=${config.min_asset_balance_usd}"
        )

    def _get_adaptive_minimum(self, total_balance_usd: float) -> float:
        """
        –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∞–¥–∞–ø—Ç–∏–≤–Ω—ã–π –º–∏–Ω–∏–º—É–º –Ω–∞ –æ—Å–Ω–æ–≤–µ –æ–±—â–µ–≥–æ –±–∞–ª–∞–Ω—Å–∞ –∏–∑ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏.

        Args:
            total_balance_usd: –û–±—â–∏–π –±–∞–ª–∞–Ω—Å –≤ USDT

        Returns:
            –ê–¥–∞–ø—Ç–∏–≤–Ω—ã–π –º–∏–Ω–∏–º—É–º –¥–ª—è —Å–¥–µ–ª–∫–∏
        """
        if not self.config.adaptive_minimums:
            # Fallback –∫ –ø—Ä–∞–≤–∏–ª—å–Ω—ã–º —Ä–µ–∂–∏–º–∞–º –±–∞–ª–∞–Ω—Å–∞
            if total_balance_usd < 1500:  # –ú–∞–ª—ã–π –±–∞–ª–∞–Ω—Å $100-$1500
                return 10.0  # –ú–∏–Ω–∏–º—É–º OKX = $10
            elif total_balance_usd < 2300:  # –°—Ä–µ–¥–Ω–∏–π –±–∞–ª–∞–Ω—Å $1500-$2300
                return 15.0  # –ù–µ–º–Ω–æ–≥–æ –±–æ–ª—å—à–µ –¥–ª—è —Å—Ä–µ–¥–Ω–µ–≥–æ –±–∞–ª–∞–Ω—Å–∞
            else:  # –ë–æ–ª—å—à–æ–π –±–∞–ª–∞–Ω—Å $2300+
                return 20.0  # –ë–æ–ª—å—à–µ –¥–ª—è –±–æ–ª—å—à–æ–≥–æ –±–∞–ª–∞–Ω—Å–∞

        # –ò—Å–ø–æ–ª—å–∑—É–µ–º –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é –∏–∑ YAML
        for level_name, level_config in self.config.adaptive_minimums.items():
            if total_balance_usd <= level_config["balance_threshold"]:
                return level_config["minimum_order_usd"]

        # –ï—Å–ª–∏ –±–∞–ª–∞–Ω—Å –±–æ–ª—å—à–µ –≤—Å–µ—Ö –ø–æ—Ä–æ–≥–æ–≤, –∏—Å–ø–æ–ª—å–∑—É–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–π —É—Ä–æ–≤–µ–Ω—å
        last_level = list(self.config.adaptive_minimums.values())[-1]
        return last_level["minimum_order_usd"]

    def check_balance(
        self,
        symbol: str,
        side: OrderSide,
        required_amount: float,
        current_price: float,
        balances: list[Balance],
    ) -> BalanceCheckResult:
        """
        –ü—Ä–æ–≤–µ—Ä—è–µ—Ç –±–∞–ª–∞–Ω—Å –ø–µ—Ä–µ–¥ –æ—Ç–∫—Ä—ã—Ç–∏–µ–º –ø–æ–∑–∏—Ü–∏–∏.

        Args:
            symbol: –¢–æ—Ä–≥–æ–≤–∞—è –ø–∞—Ä–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä, "BTC-USDT")
            side: –°—Ç–æ—Ä–æ–Ω–∞ —Å–¥–µ–ª–∫–∏ (BUY/SELL)
            required_amount: –¢—Ä–µ–±—É–µ–º–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∞–∫—Ç–∏–≤–∞
            current_price: –¢–µ–∫—É—â–∞—è —Ü–µ–Ω–∞ –∞–∫—Ç–∏–≤–∞
            balances: –°–ø–∏—Å–æ–∫ –±–∞–ª–∞–Ω—Å–æ–≤ –∞–∫–∫–∞—É–Ω—Ç–∞

        Returns:
            BalanceCheckResult —Å —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–º –ø—Ä–æ–≤–µ—Ä–∫–∏
        """
        self.total_checks += 1

        # –ò–∑–≤–ª–µ–∫–∞–µ–º –±–∞–∑–æ–≤—ã–π –∞–∫—Ç–∏–≤ –∏–∑ —Å–∏–º–≤–æ–ª–∞ (BTC –∏–∑ BTC-USDT)
        base_asset = symbol.split("-")[0]

        if side == OrderSide.BUY:
            # –î–ª—è LONG –Ω—É–∂–µ–Ω USDT
            return self._check_usdt_balance(
                symbol, required_amount, current_price, balances
            )
        else:  # OrderSide.SELL
            # –î–ª—è SHORT –Ω—É–∂–µ–Ω –∞–∫—Ç–∏–≤
            return self._check_asset_balance(
                symbol, base_asset, required_amount, current_price, balances
            )

    def _check_usdt_balance(
        self,
        symbol: str,
        required_amount: float,
        current_price: float,
        balances: list[Balance],
    ) -> BalanceCheckResult:
        """
        –ü—Ä–æ–≤–µ—Ä–∫–∞ –±–∞–ª–∞–Ω—Å–∞ USDT –¥–ª—è LONG –ø–æ–∑–∏—Ü–∏–∏.

        –ü—Ä–æ–≤–µ—Ä—è–µ—Ç —á—Ç–æ –¥–æ—Å—Ç—É–ø–Ω–æ–≥–æ USDT (—Å —É—á–µ—Ç–æ–º —Ä–µ–∑–µ—Ä–≤–∞) –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ
        –¥–ª—è –æ—Ç–∫—Ä—ã—Ç–∏—è –ø–æ–∑–∏—Ü–∏–∏ —Ç—Ä–µ–±—É–µ–º–æ–≥–æ —Ä–∞–∑–º–µ—Ä–∞.
        """
        # –ù–∞—Ö–æ–¥–∏–º –±–∞–ª–∞–Ω—Å USDT
        usdt_balance = next(
            (b for b in balances if b.currency == "USDT"),
            Balance(currency="USDT", free=0.0, used=0.0, total=0.0),
        )

        # –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –¥–æ—Å—Ç—É–ø–Ω—ã–π –±–∞–ª–∞–Ω—Å —Å —É—á–µ—Ç–æ–º —Ä–µ–∑–µ—Ä–≤–∞
        # –ò—Å–ø–æ–ª—å–∑—É–µ–º –∞–¥–∞–ø—Ç–∏–≤–Ω—ã–π –º–∏–Ω–∏–º—É–º –Ω–∞ –æ—Å–Ω–æ–≤–µ –æ–±—â–µ–≥–æ –±–∞–ª–∞–Ω—Å–∞
        total_balance_usd = sum(
            b.total for b in balances if b.currency in ["USDT", "BTC", "ETH"]
        )
        adaptive_minimum = self._get_adaptive_minimum(total_balance_usd)

        reserve_amount = max(
            usdt_balance.free * (self.config.usdt_reserve_percent / 100.0),
            adaptive_minimum,  # –ê–¥–∞–ø—Ç–∏–≤–Ω—ã–π –º–∏–Ω–∏–º—É–º –≤–º–µ—Å—Ç–æ –∂–µ—Å—Ç–∫–æ–≥–æ
        )
        available_usdt = usdt_balance.free - reserve_amount

        # –¢—Ä–µ–±—É–µ–º–∞—è —Å—É–º–º–∞ –≤ USDT
        required_usdt = required_amount * current_price

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ—Å—Ç—å —Å—Ä–µ–¥—Å—Ç–≤
        if available_usdt >= required_usdt:
            # ‚úÖ –î–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤
            if self.config.log_all_checks:
                logger.debug(
                    f"‚úÖ {symbol} LONG: Balance OK "
                    f"(available ${available_usdt:.2f}, need ${required_usdt:.2f})"
                )

            return BalanceCheckResult(
                allowed=True,
                reason="Sufficient USDT balance",
                available_balance=available_usdt,
                required_balance=required_usdt,
                currency="USDT",
            )
        else:
            # ‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤
            self._record_blocked_signal(symbol, "LONG")

            reason = (
                f"Insufficient USDT balance "
                f"(available ${available_usdt:.2f}, need ${required_usdt:.2f})"
            )

            logger.warning(f"‚ö†Ô∏è {symbol} LONG BLOCKED: {reason}")
            logger.info(
                f"üí° TIP: Free USDT: ${usdt_balance.free:.2f}, "
                f"Reserved: ${reserve_amount:.2f} ({self.config.usdt_reserve_percent}%)"
            )

            return BalanceCheckResult(
                allowed=False,
                reason=reason,
                available_balance=available_usdt,
                required_balance=required_usdt,
                currency="USDT",
            )

    def _check_asset_balance(
        self,
        symbol: str,
        asset: str,
        required_amount: float,
        current_price: float,
        balances: list[Balance],
    ) -> BalanceCheckResult:
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ –±–∞–ª–∞–Ω—Å–∞ –∞–∫—Ç–∏–≤–∞ –¥–ª—è SHORT –ø–æ–∑–∏—Ü–∏–∏."""
        # –ù–∞—Ö–æ–¥–∏–º –±–∞–ª–∞–Ω—Å –∞–∫—Ç–∏–≤–∞
        asset_balance = next(
            (b for b in balances if b.currency == asset),
            Balance(currency=asset, free=0.0, used=0.0, total=0.0),
        )

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ª–∏ –∞–∫—Ç–∏–≤–∞
        available_amount = asset_balance.free
        available_usd = available_amount * current_price

        # –ò—Å–ø–æ–ª—å–∑—É–µ–º –∞–¥–∞–ø—Ç–∏–≤–Ω—ã–π –º–∏–Ω–∏–º—É–º
        total_balance_usd = sum(
            b.total for b in balances if b.currency in ["USDT", "BTC", "ETH"]
        )
        adaptive_minimum = self._get_adaptive_minimum(total_balance_usd)

        if available_amount >= required_amount and available_usd >= adaptive_minimum:
            if self.config.log_all_checks:
                logger.debug(
                    f"‚úÖ {symbol} SHORT: Balance OK "
                    f"(have {available_amount:.6f} {asset} = ${available_usd:.2f})"
                )

            return BalanceCheckResult(
                allowed=True,
                reason=f"Sufficient {asset} balance",
                available_balance=available_amount,
                required_balance=required_amount,
                currency=asset,
            )
        else:
            self._record_blocked_signal(symbol, "SHORT")

            if available_amount < required_amount:
                reason = (
                    f"Insufficient {asset} balance "
                    f"(have {available_amount:.6f}, need {required_amount:.6f})"
                )
            else:
                reason = (
                    f"{asset} balance too small "
                    f"(${available_usd:.2f} < ${adaptive_minimum})"
                )

            logger.warning(f"‚ö†Ô∏è {symbol} SHORT BLOCKED: {reason}")
            logger.info(
                f"üí° TIP: To trade SHORT on {symbol}, you need to hold {asset} "
                f"(buy via LONG signal or manual purchase)"
            )

            return BalanceCheckResult(
                allowed=False,
                reason=reason,
                available_balance=available_amount,
                required_balance=required_amount,
                currency=asset,
            )

    def _record_blocked_signal(self, symbol: str, direction: str) -> None:
        """–ó–∞–ø–∏—Å—ã–≤–∞–µ—Ç —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ —Å–∏–≥–Ω–∞–ª–∞."""
        key = f"{symbol}_{direction}"
        self.blocked_signals[key] = self.blocked_signals.get(key, 0) + 1
        self.total_blocked += 1

    def get_statistics(self) -> Dict[str, any]:
        """
        –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É —Ä–∞–±–æ—Ç—ã –º–æ–¥—É–ª—è.

        Returns:
            –°–ª–æ–≤–∞—Ä—å —Å–æ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–æ–π –ø—Ä–æ–≤–µ—Ä–æ–∫ –∏ –±–ª–æ–∫–∏—Ä–æ–≤–æ–∫
        """
        return {
            "total_checks": self.total_checks,
            "total_blocked": self.total_blocked,
            "block_rate": (
                (self.total_blocked / self.total_checks * 100)
                if self.total_checks > 0
                else 0.0
            ),
            "blocked_by_pair": self.blocked_signals,
        }

    def log_statistics(self) -> None:
        """–í—ã–≤–æ–¥–∏—Ç —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –≤ –ª–æ–≥."""
        stats = self.get_statistics()

        if stats["total_checks"] == 0:
            logger.info("üìä Balance Checker: No checks performed yet")
            return

        logger.info("‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ")
        logger.info("üìä BALANCE CHECKER STATISTICS")
        logger.info("‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ")
        logger.info(f"Total checks: {stats['total_checks']}")
        logger.info(f"Total blocked: {stats['total_blocked']}")
        logger.info(f"Block rate: {stats['block_rate']:.1f}%")

        if stats["blocked_by_pair"]:
            logger.info("\nBlocked signals by pair:")
            for key, count in sorted(
                stats["blocked_by_pair"].items(), key=lambda x: x[1], reverse=True
            ):
                logger.info(f"  {key}: {count} signals")

        logger.info("‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ")
