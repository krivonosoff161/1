"""
Auto-Reconnect WebSocket Manager –¥–ª—è Futures —Ç–æ—Ä–≥–æ–≤–ª–∏.

–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –ø—Ä–∏ –æ–±—Ä—ã–≤–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è,
–º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –∑–¥–æ—Ä–æ–≤—å—è WebSocket –∏ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ–¥–ø–∏—Å–æ–∫.
"""

import asyncio
import json
import time
from typing import Callable, Dict, Optional
from collections import deque

import aiohttp
from loguru import logger


class FuturesWebSocketManager:
    """
    –ú–µ–Ω–µ–¥–∂–µ—Ä WebSocket —Å –∞–≤—Ç–æ-—Ä–µ–∫–æ–Ω–Ω–µ–∫—Ç–æ–º –¥–ª—è Futures.
    
    –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–∞–µ—Ç—Å—è –ø—Ä–∏ –æ–±—Ä—ã–≤–µ —Å–≤—è–∑–∏,
    –≤–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç –ø–æ–¥–ø–∏—Å–∫–∏ –∏ –º–æ–Ω–∏—Ç–æ—Ä–∏—Ç –∑–¥–æ—Ä–æ–≤—å–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è.
    
    Attributes:
        ws_url: URL WebSocket –¥–ª—è Futures
        ws: WebSocket —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ
        connected: –°—Ç–∞—Ç—É—Å –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è
        subscribed_channels: –ü–æ–¥–ø–∏—Å–∞–Ω–Ω—ã–µ –∫–∞–Ω–∞–ª—ã
        reconnect_attempts: –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–ø—ã—Ç–æ–∫ –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è
        max_reconnect_attempts: –ú–∞–∫—Å–∏–º—É–º –ø–æ–ø—ã—Ç–æ–∫
        reconnect_delay: –ó–∞–¥–µ—Ä–∂–∫–∞ –º–µ–∂–¥—É –ø–æ–ø—ã—Ç–∫–∞–º–∏
        heartbeat_interval: –ò–Ω—Ç–µ—Ä–≤–∞–ª heartbeat
        last_heartbeat: –í—Ä–µ–º—è –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ heartbeat
        callbacks: Callbacks –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –¥–∞–Ω–Ω—ã—Ö
    """
    
    def __init__(self, ws_url: str = "wss://ws.okx.com:8443/ws/v5/public",
                 max_reconnect_attempts: int = 10,
                 reconnect_delay: float = 5.0,
                 heartbeat_interval: float = 30.0):
        """
        –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è WebSocket Manager.
        
        Args:
            ws_url: URL WebSocket
            max_reconnect_attempts: –ú–∞–∫—Å–∏–º—É–º –ø–æ–ø—ã—Ç–æ–∫ –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è
            reconnect_delay: –ó–∞–¥–µ—Ä–∂–∫–∞ –º–µ–∂–¥—É –ø–æ–ø—ã—Ç–∫–∞–º–∏ (—Å–µ–∫)
            heartbeat_interval: –ò–Ω—Ç–µ—Ä–≤–∞–ª heartbeat (—Å–µ–∫)
        """
        self.ws_url = ws_url
        self.ws: Optional[aiohttp.ClientWebSocketResponse] = None
        self.connected = False
        self.subscribed_channels: Dict[str, dict] = {}
        self.callbacks: Dict[str, Callable] = {}
        
        self.reconnect_attempts = 0
        self.max_reconnect_attempts = max_reconnect_attempts
        self.reconnect_delay = reconnect_delay
        self.heartbeat_interval = heartbeat_interval
        self.last_heartbeat = time.time()
        
        self.should_reconnect = True
        self.reconnect_task: Optional[asyncio.Task] = None
        self.heartbeat_task: Optional[asyncio.Task] = None
        self.listener_task: Optional[asyncio.Task] = None
        
        logger.info(
            f"FuturesWebSocketManager –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω: "
            f"url={ws_url}, max_attempts={max_reconnect_attempts}"
        )
    
    async def connect(self) -> bool:
        """
        –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ WebSocket.
        
        Returns:
            True –µ—Å–ª–∏ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ —É—Å–ø–µ—à–Ω–æ
        """
        try:
            session = aiohttp.ClientSession()
            self.ws = await session.ws_connect(self.ws_url)
            self.connected = True
            self.reconnect_attempts = 0
            self.last_heartbeat = time.time()
            
            # –ó–∞–ø—É—Å–∫–∞–µ–º –∑–∞–¥–∞—á–∏
            self.listener_task = asyncio.create_task(self._listen_for_data())
            self.heartbeat_task = asyncio.create_task(self._heartbeat_loop())
            
            logger.info("‚úÖ WebSocket –ø–æ–¥–∫–ª—é—á–µ–Ω")
            return True
            
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è WebSocket: {e}")
            return False
    
    async def disconnect(self):
        """–û—Ç–∫–ª—é—á–µ–Ω–∏–µ –æ—Ç WebSocket."""
        self.should_reconnect = False
        self.connected = False
        
        # –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∑–∞–¥–∞—á–∏
        if self.reconnect_task:
            self.reconnect_task.cancel()
        if self.heartbeat_task:
            self.heartbeat_task.cancel()
        if self.listener_task:
            self.listener_task.cancel()
        
        if self.ws:
            await self.ws.close()
        
        logger.info("üîå WebSocket –æ—Ç–∫–ª—é—á–µ–Ω")
    
    async def subscribe(self, channel: str, inst_id: str, 
                       callback: Callable) -> bool:
        """
        –ü–æ–¥–ø–∏—Å–∫–∞ –Ω–∞ –∫–∞–Ω–∞–ª.
        
        Args:
            channel: –ö–∞–Ω–∞–ª (tickers, trades, books, –∏ —Ç.–¥.)
            inst_id: ID –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞ (BTC-USDT-SWAP)
            callback: Callback –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –¥–∞–Ω–Ω—ã—Ö
            
        Returns:
            True –µ—Å–ª–∏ –ø–æ–¥–ø–∏—Å–∫–∞ —É—Å–ø–µ—à–Ω–∞
        """
        if not self.connected or not self.ws:
            logger.error("WebSocket –Ω–µ –ø–æ–¥–∫–ª—é—á–µ–Ω")
            return False
        
        try:
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º callback
            key = f"{channel}:{inst_id}"
            self.callbacks[key] = callback
            
            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –ø–æ–¥–ø–∏—Å–∫—É
            subscribe_msg = {
                "op": "subscribe",
                "args": [{"channel": channel, "instId": inst_id}]
            }
            
            await self.ws.send_str(json.dumps(subscribe_msg))
            
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø–æ–¥–ø–∏—Å–∫–µ
            self.subscribed_channels[key] = {
                "channel": channel,
                "instId": inst_id
            }
            
            logger.info(f"üìä –ü–æ–¥–ø–∏—Å–∫–∞: {channel} - {inst_id}")
            return True
            
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø–æ–¥–ø–∏—Å–∫–∏: {e}")
            return False
    
    async def _listen_for_data(self):
        """–°–ª—É—à–∞–µ–º –¥–∞–Ω–Ω—ã–µ –æ—Ç WebSocket."""
        while self.should_reconnect:
            try:
                async for msg in self.ws:
                    if msg.type == aiohttp.WSMsgType.TEXT:
                        data = json.loads(msg.data)
                        await self._handle_data(data)
                        
                    elif msg.type == aiohttp.WSMsgType.ERROR:
                        logger.error(f"WebSocket error: {self.ws.exception()}")
                        await self._handle_disconnect()
                        break
                        
                    elif msg.type == aiohttp.WSMsgType.CLOSE:
                        logger.warning("WebSocket –∑–∞–∫—Ä—ã—Ç —Å–µ—Ä–≤–µ—Ä–æ–º")
                        await self._handle_disconnect()
                        break
                        
            except Exception as e:
                logger.error(f"–û—à–∏–±–∫–∞ –≤ WebSocket listener: {e}")
                await self._handle_disconnect()
                
            await asyncio.sleep(1)
    
    async def _handle_data(self, data: dict):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –¥–∞–Ω–Ω—ã—Ö –æ—Ç WebSocket."""
        try:
            # –û–±–Ω–æ–≤–ª—è–µ–º heartbeat
            self.last_heartbeat = time.time()
            
            # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –æ—Ç–≤–µ—Ç—ã
            event = data.get("event")
            if event == "subscribe":
                logger.info(f"‚úÖ –ü–æ–¥–ø–∏—Å–∫–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∞: {data.get('arg', {})}")
                return
            elif event == "error":
                logger.error(f"WebSocket error: {data}")
                return
            
            # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –¥–∞–Ω–Ω—ã–µ
            arg = data.get("arg", {})
            channel = arg.get("channel")
            inst_id = arg.get("instId")
            
            if channel and inst_id:
                key = f"{channel}:{inst_id}"
                if key in self.callbacks:
                    await self.callbacks[key](data)
                    
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –¥–∞–Ω–Ω—ã—Ö: {e}")
    
    async def _handle_disconnect(self):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—Ç–∫–ª—é—á–µ–Ω–∏—è."""
        logger.warning("üîå WebSocket –æ—Ç–∫–ª—é—á–µ–Ω")
        self.connected = False
        
        if self.should_reconnect:
            await self._reconnect()
    
    async def _reconnect(self):
        """–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ."""
        if self.reconnect_attempts >= self.max_reconnect_attempts:
            logger.error(
                f"‚ùå –ú–∞–∫—Å–∏–º—É–º –ø–æ–ø—ã—Ç–æ–∫ –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –¥–æ—Å—Ç–∏–≥–Ω—É—Ç "
                f"({self.max_reconnect_attempts})"
            )
            self.should_reconnect = False
            return
        
        self.reconnect_attempts += 1
        logger.info(
            f"üîÑ –ü–æ–ø—ã—Ç–∫–∞ –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è {self.reconnect_attempts}/"
            f"{self.max_reconnect_attempts}..."
        )
        
        await asyncio.sleep(self.reconnect_delay)
        
        if await self.connect():
            # –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø–æ–¥–ø–∏—Å–∫–∏
            await self._restore_subscriptions()
    
    async def _restore_subscriptions(self):
        """–í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ–¥–ø–∏—Å–æ–∫ –ø–æ—Å–ª–µ –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è."""
        if len(self.subscribed_channels) == 0:
            return
        
        logger.info(f"üìä –í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ {len(self.subscribed_channels)} –ø–æ–¥–ø–∏—Å–æ–∫...")
        
        for key, info in self.subscribed_channels.items():
            channel = info["channel"]
            inst_id = info["instId"]
            callback = self.callbacks.get(key)
            
            if callback:
                await self.subscribe(channel, inst_id, callback)
    
    async def _heartbeat_loop(self):
        """Heartbeat –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥."""
        while self.should_reconnect:
            await asyncio.sleep(self.heartbeat_interval)
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–π heartbeat
            time_since_heartbeat = time.time() - self.last_heartbeat
            
            if time_since_heartbeat > self.heartbeat_interval * 2:
                logger.warning(
                    f"‚ö†Ô∏è Heartbeat timeout: {time_since_heartbeat:.1f}s"
                )
                await self._handle_disconnect()
                break
    
    def get_status(self) -> Dict[str, any]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞ WebSocket."""
        return {
            "connected": self.connected,
            "subscribed_channels": len(self.subscribed_channels),
            "reconnect_attempts": self.reconnect_attempts,
            "last_heartbeat": self.last_heartbeat,
            "time_since_heartbeat": time.time() - self.last_heartbeat,
        }
    
    def __repr__(self) -> str:
        """–°—Ç—Ä–æ–∫–æ–≤–æ–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ –º–µ–Ω–µ–¥–∂–µ—Ä–∞."""
        status = self.get_status()
        return (
            f"FuturesWebSocketManager("
            f"connected={self.connected}, "
            f"channels={status['subscribed_channels']}, "
            f"reconnect={self.reconnect_attempts}/{self.max_reconnect_attempts}"
            f")"
        )

