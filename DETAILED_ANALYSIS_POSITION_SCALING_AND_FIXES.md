# ДЕТАЛЬНЫЙ АНАЛИЗ: МАСШТАБИРОВАНИЕ ПОЗИЦИЙ И ИСПРАВЛЕНИЯ

**Дата:** 2025-12-21  
**Цель:** Проработка системы лестничного добавления к позициям, исправление частичного закрытия, анализ влияния на систему

---

## 1. АНАЛИЗ ПРОБЛЕМЫ: ЧАСТИЧНОЕ ЗАКРЫТИЕ НА МАЛЫХ ПОЗИЦИЯХ

### Текущая логика частичного закрытия

**Код проверки минимального размера:**
```5860:5890:src/strategies/scalping/futures/position_manager.py
# ✅ ИСПРАВЛЕНИЕ: Проверка минимального размера ДО округления
# Если размер частичного закрытия меньше минимума, проверяем варианты
if close_size_contracts < min_sz:
    logger.warning(
        f"⚠️ Частичное закрытие {symbol}: размер {close_size_contracts:.6f} контрактов "
        f"меньше минимума {min_sz:.6f}. Текущий размер={abs(current_size):.6f}, "
        f"fraction={fraction*100:.0f}%."
    )
    
    # Проверяем, можем ли закрыть всю позицию
    if abs(current_size) >= min_sz:
        # Если вся позиция >= минимума, закрываем всю
        close_size_contracts = abs(current_size)
```

**Проблема:** Нет проверки **минимальной стоимости позиции** (в USD). Если позиция стоит $1, частичное закрытие закроет всю позицию за $1, что неэффективно (комиссии съедят прибыль).

### ✅ РЕШЕНИЕ: Минимальная стоимость для Partial TP

**Логика:**
1. Проверять минимальную стоимость закрываемой части (например, минимум $5-10 USD)
2. Если размер частичного закрытия < минимума → НЕ закрывать частично, держать позицию
3. Если вся позиция < минимума → можно закрыть всю (но это должно быть редко)

**Исправление:**
```python
# В close_partial_position():
MIN_PARTIAL_CLOSE_VALUE_USD = 5.0  # Минимальная стоимость частичного закрытия $5

# После расчета close_size_contracts:
close_size_usd = close_size_contracts * ct_val * current_price

if close_size_usd < MIN_PARTIAL_CLOSE_VALUE_USD:
    logger.warning(
        f"⚠️ Частичное закрытие {symbol}: стоимость {close_size_usd:.2f} USD "
        f"меньше минимума ${MIN_PARTIAL_CLOSE_VALUE_USD:.2f}. "
        f"Пропускаем частичное закрытие (неэффективно после комиссий)."
    )
    return None  # НЕ закрываем частично

# Если вся позиция < минимума, можно закрыть всю (но это редко)
total_position_value_usd = abs(current_size) * ct_val * current_price
if total_position_value_usd < MIN_PARTIAL_CLOSE_VALUE_USD:
    logger.warning(
        f"⚠️ Вся позиция {symbol} стоит ${total_position_value_usd:.2f} < ${MIN_PARTIAL_CLOSE_VALUE_USD:.2f}. "
        f"Частичное закрытие неэффективно, держим позицию."
    )
    return None
```

**Адаптивность:** Минимальная стоимость может быть адаптивной:
- По балансу: для small баланса → $3, для large → $10
- По режиму: для ranging (меньше движение) → $5, для trending (больше движение) → $10

---

## 2. СИСТЕМА ЛЕСТНИЧНОГО ДОБАВЛЕНИЯ К ПОЗИЦИЯМ

### 2.1. Концепция "Лестницы" (Position Scaling Ladder)

**Идея:**
- 1-е добавление: 100% базового размера
- 2-е добавление: 70% базового размера
- 3-е добавление: 50% базового размера
- 4-е добавление: 30% базового размера
- 5-е добавление: 20% базового размера

**Преимущества:**
- Не перегружает баланс маржой
- Уменьшает риск при каждом добавлении
- Позволяет усреднять позицию при убытке
- Контролирует общий размер позиции

### 2.2. Архитектура модуля PositionScalingManager

**Новый модуль:** `src/strategies/scalping/futures/positions/position_scaling_manager.py`

**Ответственность:**
1. Расчет размера следующего добавления по лестнице
2. Проверка лимитов (баланс, маржа, максимальный размер позиции)
3. Учет режима баланса, режима рынка, рисков
4. Хранение истории добавлений к позиции

**Структура:**
```python
class PositionScalingManager:
    """
    Менеджер масштабирования позиций (лестничное добавление).
    
    Отвечает за:
    - Расчет размера добавления по лестнице
    - Проверку лимитов (баланс, маржа, максимальный размер)
    - Адаптацию под режим баланса и режим рынка
    """
    
    def __init__(
        self,
        client,
        config_manager,
        margin_calculator,
        risk_manager,
        data_registry,
        scalping_config,
    ):
        self.client = client
        self.config_manager = config_manager
        self.margin_calculator = margin_calculator
        self.risk_manager = risk_manager
        self.data_registry = data_registry
        self.scalping_config = scalping_config
        
        # История добавлений: symbol -> list of {time, size_usd, leverage, ...}
        self._scaling_history: Dict[str, List[Dict[str, Any]]] = {}
        
        # Лимиты добавлений: symbol -> max_additions
        self._max_additions_by_symbol: Dict[str, int] = {}
    
    async def calculate_next_addition_size(
        self,
        symbol: str,
        existing_position: Dict[str, Any],
        signal: Dict[str, Any],
        balance: float,
        balance_profile: str,
        regime: str,
    ) -> Optional[float]:
        """
        Рассчитать размер следующего добавления к позиции по лестнице.
        
        Returns:
            Размер добавления в USD или None если нельзя добавить
        """
        # 1. Проверка количества добавлений (максимум 5)
        # 2. Расчет базового размера для добавления (по лестнице)
        # 3. Проверка лимитов (баланс, маржа, максимальный размер позиции)
        # 4. Учет режима баланса и режима рынка
        # 5. Возврат размера добавления
        pass
    
    async def can_add_to_position(
        self,
        symbol: str,
        existing_position: Dict[str, Any],
        signal: Dict[str, Any],
        balance: float,
    ) -> Tuple[bool, str]:
        """
        Проверка возможности добавления к позиции.
        
        Returns:
            (can_add: bool, reason: str)
        """
        # 1. Проверка количества добавлений
        # 2. Проверка интервала (минимум 30-60 секунд)
        # 3. Проверка убытка (не больше -2%)
        # 4. Проверка лимитов баланса и маржи
        # 5. Проверка максимального размера позиции
        pass
```

### 2.3. Логика расчета размера добавления

**Лестница (Ladder):**
```python
# Базовые коэффициенты лестницы (можно настроить в конфиге)
SCALING_LADDER = {
    1: 1.0,    # 100% базового размера
    2: 0.7,    # 70% базового размера
    3: 0.5,    # 50% базового размера
    4: 0.3,    # 30% базового размера
    5: 0.2,    # 20% базового размера
}

# Адаптация по режиму баланса:
# - small: более консервативно (меньше коэффициенты)
# - medium: стандартно
# - large: можно более агрессивно

# Адаптация по режиму рынка:
# - trending: можно более агрессивно (больше коэффициенты)
# - ranging: консервативно (меньше коэффициенты)
# - choppy: очень консервативно (минимальные коэффициенты)
```

**Расчет:**
```python
async def calculate_next_addition_size(...):
    # 1. Получаем количество уже сделанных добавлений
    additions_count = len(self._scaling_history.get(symbol, []))
    
    if additions_count >= 5:
        return None  # Максимум 5 добавлений
    
    # 2. Получаем коэффициент лестницы
    base_coefficient = SCALING_LADDER.get(additions_count + 1, 0.2)
    
    # 3. Адаптация по режиму баланса
    if balance_profile == "small":
        coefficient = base_coefficient * 0.8  # -20% для small
    elif balance_profile == "large":
        coefficient = base_coefficient * 1.1  # +10% для large
    else:
        coefficient = base_coefficient
    
    # 4. Адаптация по режиму рынка
    if regime == "trending":
        coefficient = coefficient * 1.1  # +10% для trending
    elif regime == "choppy":
        coefficient = coefficient * 0.7  # -30% для choppy
    
    # 5. Рассчитываем базовый размер (как для новой позиции)
    base_size_usd = await self._calculate_base_position_size(
        balance, signal, regime, balance_profile
    )
    
    # 6. Размер добавления = базовый размер * коэффициент лестницы
    addition_size_usd = base_size_usd * coefficient
    
    # 7. Проверка лимитов (см. раздел 2.4)
    # ...
    
    return addition_size_usd
```

### 2.4. Проверка лимитов

**Критические проверки:**

1. **Максимальный размер позиции (per symbol):**
```python
# Получаем текущий размер позиции
current_size_usd = existing_position.get("position_value_usd", 0)

# Получаем максимальный размер из конфига (по режиму баланса)
max_position_size_usd = self._get_max_position_size_usd(
    balance_profile, regime
)

# Проверяем что после добавления не превысим максимум
if current_size_usd + addition_size_usd > max_position_size_usd:
    logger.warning(
        f"⚠️ Добавление к {symbol}: превысит max_position_size "
        f"({current_size_usd:.2f} + {addition_size_usd:.2f} > {max_position_size_usd:.2f})"
    )
    return None
```

2. **Доступная маржа:**
```python
# Получаем текущую использованную маржу
current_margin_used = await self._get_total_margin_used()

# Рассчитываем маржу для добавления
addition_leverage = signal.get("leverage", 3)
addition_margin_needed = addition_size_usd / addition_leverage

# Получаем доступную маржу
available_margin = balance - current_margin_used

if addition_margin_needed > available_margin * 0.8:  # Оставляем 20% резерв
    logger.warning(
        f"⚠️ Добавление к {symbol}: недостаточно маржи "
        f"(нужно {addition_margin_needed:.2f}, доступно {available_margin:.2f})"
    )
    return None
```

3. **Максимальная маржа на позицию (per symbol):**
```python
# Рассчитываем максимальную маржу на позицию (из конфига)
max_margin_per_position = self._calculate_max_margin_per_position(
    balance, balance_profile, regime
)

# Текущая маржа на эту позицию
current_position_margin = existing_position.get("margin", 0)

# Маржа после добавления
new_position_margin = current_position_margin + addition_margin_needed

if new_position_margin > max_margin_per_position:
    logger.warning(
        f"⚠️ Добавление к {symbol}: превысит max_margin_per_position "
        f"({new_position_margin:.2f} > {max_margin_per_position:.2f})"
    )
    return None
```

4. **Общий лимит позиций:**
```python
# Проверяем что не превысим общий лимит открытых позиций
open_positions_count = await self._get_open_positions_count()

max_open_positions = self._get_max_open_positions(balance_profile)

if open_positions_count >= max_open_positions:
    logger.warning(
        f"⚠️ Добавление к {symbol}: достигнут лимит открытых позиций "
        f"({open_positions_count}/{max_open_positions})"
    )
    return None
```

### 2.5. Интеграция с существующими модулями

**Модули, которые нужно изменить:**

1. **SignalCoordinator** (`signal_coordinator.py`):
   - Вместо блокировки нового сигнала в том же направлении → проверка возможности добавления
   - Если можно добавить → вызов `PositionScalingManager.calculate_next_addition_size()`
   - Размещение ордера с рассчитанным размером

2. **RiskManager** (`risk_manager.py`):
   - Добавить метод `calculate_max_margin_per_position()` для расчета максимальной маржи на позицию
   - Учитывать режим баланса, режим рынка, волатильность

3. **MarginCalculator** (`margin_calculator.py`):
   - Добавить метод `can_add_margin()` для проверки возможности добавления маржи
   - Учитывать изолированную маржу (isolated margin)

4. **ConfigManager** (`config_manager.py`):
   - Добавить параметры для настройки лестницы в конфиг
   - Параметры по режиму баланса и режиму рынка

5. **PositionRegistry** (`position_registry.py`):
   - Хранить историю добавлений к позиции в метаданных
   - Метод `add_scaling_entry()` для записи добавления

---

## 3. ВЛИЯНИЕ НА СУЩЕСТВУЮЩУЮ СИСТЕМУ

### 3.1. Модули, которые будут затронуты

| Модуль | Изменения | Риски |
|--------|-----------|-------|
| `SignalCoordinator` | Логика разрешения добавления вместо блокировки | Средний - нужно тщательно тестировать проверки |
| `RiskManager` | Новые методы расчета лимитов | Низкий - добавление методов, не изменение существующих |
| `MarginCalculator` | Новые методы проверки маржи | Низкий - добавление методов |
| `PositionManager` | Интеграция с PositionScalingManager | Средний - нужно правильно обновлять размер позиции |
| `ConfigManager` | Новые параметры конфига | Низкий - только добавление параметров |
| `PositionRegistry` | Хранение истории добавлений | Низкий - добавление полей в метаданные |
| `ExitAnalyzer` | Учет размера позиции при анализе | Низкий - может понадобиться учитывать размер при partial TP |

### 3.2. Потенциальные ошибки и их предотвращение

**Ошибка 1: Перегрузка баланса маржой**
- **Причина:** Слишком большие добавления или слишком много добавлений
- **Предотвращение:**
  - Проверка доступной маржи перед каждым добавлением
  - Ограничение максимального количества добавлений (5)
  - Лестница уменьшает размер каждого добавления

**Ошибка 2: Превышение максимального размера позиции**
- **Причина:** Неправильный расчет max_position_size или игнорирование проверки
- **Предотвращение:**
  - Строгая проверка перед каждым добавлением
  - Логирование всех проверок
  - Fallback на блокировку если проверка не прошла

**Ошибка 3: Race condition при одновременных добавлениях**
- **Причина:** Несколько сигналов одновременно пытаются добавить к одной позиции
- **Предотвращение:**
  - Блокировка на символ (`asyncio.Lock` для каждого символа)
  - Проверка количества добавлений перед каждым

**Ошибка 4: Неправильный расчет размера добавления**
- **Причина:** Ошибка в формуле лестницы или адаптации
- **Предотвращение:**
  - Тестирование всех сценариев (small/medium/large баланс, все режимы)
  - Логирование всех расчетов
  - Валидация результата (проверка что размер > 0 и < max)

**Ошибка 5: Частичное закрытие на увеличенной позиции**
- **Причина:** После добавлений позиция стала большой, partial TP закрывает большую часть
- **Предотвращение:**
  - Учитывать размер позиции при расчете fraction для partial TP
  - Для больших позиций использовать меньший fraction

---

## 4. ПАРАМЕТРЫ УВЕЛИЧЕНИЯ ПОЗИЦИИ

### 4.1. Обсуждение консервативности

**Текущие предложения:**
- Максимум 5 добавлений
- Интервал 30-60 секунд
- Убыток не больше -2%

**Вопрос:** Не слишком ли консервативно?

**Анализ:**

1. **Максимум 5 добавлений:**
   - ✅ Достаточно для усреднения позиции
   - ✅ Не перегружает баланс (при лестнице: 100% + 70% + 50% + 30% + 20% = 270% базового размера)
   - ⚠️ Можно увеличить до 7, но это рискованнее

2. **Интервал 30-60 секунд:**
   - ✅ Защищает от слишком частых добавлений
   - ✅ Дает время для анализа рынка
   - ⚠️ Можно уменьшить до 20-30 секунд для более агрессивной стратегии

3. **Убыток -2%:**
   - ✅ Защищает от добавления в глубокий убыток
   - ⚠️ Можно увеличить до -3% для более агрессивной стратегии усреднения

**Рекомендация:**
- **Базовая настройка (консервативная):** 5 добавлений, 60 секунд, -2%
- **Агрессивная настройка:** 7 добавлений, 30 секунд, -3%
- **Адаптивность:** Можно настроить по режиму баланса и режиму рынка в конфиге

### 4.2. Адаптивные параметры

**По режиму баланса:**
```yaml
position_scaling:
  by_balance:
    small:
      max_additions: 3
      min_interval_seconds: 60
      max_loss_for_addition: -1.5%  # Более консервативно
      ladder: [1.0, 0.6, 0.4]  # Меньшие коэффициенты
    
    medium:
      max_additions: 5
      min_interval_seconds: 45
      max_loss_for_addition: -2.0%
      ladder: [1.0, 0.7, 0.5, 0.3, 0.2]
    
    large:
      max_additions: 7
      min_interval_seconds: 30
      max_loss_for_addition: -3.0%  # Более агрессивно
      ladder: [1.0, 0.8, 0.6, 0.4, 0.3, 0.2, 0.15]
```

**По режиму рынка:**
```yaml
position_scaling:
  by_regime:
    trending:
      ladder_multiplier: 1.1  # +10% к коэффициентам лестницы
      max_loss_for_addition: -2.5%  # Можно добавить при большем убытке
    
    ranging:
      ladder_multiplier: 0.9  # -10% к коэффициентам лестницы
      max_loss_for_addition: -1.5%  # Более консервативно
    
    choppy:
      ladder_multiplier: 0.7  # -30% к коэффициентам лестницы
      max_loss_for_addition: -1.0%  # Очень консервативно
      max_additions_override: 3  # Максимум 3 добавления
```

---

## 5. ПРИОРИТЕТЫ АВТОНОМНЫХ РЕШЕНИЙ (С ТОЧКИ ЗРЕНИЯ ТРЕЙДЕРА)

### Приоритет 1: Критичные для прибыльности

1. **✅ Автономная оптимизация размера позиции на основе дневного PnL**
   - **Почему:** Защита от больших просадок, автоматическое снижение риска при убытках
   - **Реализация:** Простая (анализ daily_pnl, изменение базового размера)
   - **Риск:** Низкий (только изменение базового размера)

2. **✅ Автономная коррекция TP/SL на основе волатильности**
   - **Почему:** Улучшает результаты в разных рыночных условиях
   - **Реализация:** Средняя (нужен расчет текущей vs средней волатильности)
   - **Риск:** Средний (нужно правильно рассчитывать волатильность)

### Приоритет 2: Улучшение результатов

3. **⏳ Автономное изменение размера позиции (DCA)**
   - **Почему:** Усреднение позиции при убытке, увеличение при прибыли
   - **Реализация:** Сложная (нужна интеграция с PositionScalingManager)
   - **Риск:** Высокий (может привести к перегрузке баланса)

### Приоритет 3: Дополнительно

4. **⏳ Автономное переключение режима торговли**
   - **Почему:** Адаптация к изменяющимся условиям
   - **Реализация:** Очень сложная (нужен анализ результатов, переключение стратегии)
   - **Риск:** Очень высокий (может привести к непредсказуемому поведению)

5. **⏳ Автономное временное приостановление торговли**
   - **Почему:** Защита от серии убытков
   - **Реализация:** Простая (уже есть emergency stop, можно расширить)
   - **Риск:** Низкий (но может пропустить хорошие возможности)

---

## 6. ПЛАН РЕАЛИЗАЦИИ

### Этап 1: Исправления (Приоритет 1)

1. ✅ Исправить ошибку форматирования в AdaptiveLeverage
2. ✅ Исправить чтение leverage с биржи
3. ✅ Исправить расчет position_value
4. ✅ Исправить race conditions в DRIFT_ADD/REMOVE
5. ✅ Добавить минимальную стоимость для Partial TP ($5-10 USD)

**Время:** 2-3 часа

### Этап 2: PositionScalingManager (Приоритет 1)

1. ✅ Создать модуль `PositionScalingManager`
2. ✅ Реализовать расчет размера добавления по лестнице
3. ✅ Реализовать проверки лимитов
4. ✅ Интеграция с SignalCoordinator
5. ✅ Добавить параметры в конфиг
6. ✅ Тестирование

**Время:** 4-6 часов

### Этап 3: Автономные решения (Приоритет 2)

1. ✅ Автономная оптимизация размера позиции на основе дневного PnL
2. ✅ Автономная коррекция TP/SL на основе волатильности

**Время:** 3-4 часа

### Этап 4: Дополнительно (Приоритет 3)

1. ⏳ Автономное изменение размера позиции (DCA)
2. ⏳ Другие автономные решения

**Время:** По необходимости

---

## ИТОГОВЫЕ РЕКОМЕНДАЦИИ

### Для немедленной реализации:

1. ✅ **Исправить все найденные ошибки** (Этап 1)
2. ✅ **Добавить минимальную стоимость для Partial TP** ($5-10 USD, адаптивно по балансу)
3. ✅ **Реализовать PositionScalingManager** с консервативными параметрами (5 добавлений, 60 сек, -2%)

### Для обсуждения:

1. **Параметры увеличения позиции:**
   - Базовые: 5 добавлений, 60 сек, -2% (консервативно)
   - Можно адаптировать по режиму баланса и режиму рынка

2. **Лестница:**
   - Стандартная: [1.0, 0.7, 0.5, 0.3, 0.2]
   - Можно адаптировать по режиму баланса и режиму рынка

3. **Автономные решения:**
   - Начать с: оптимизация размера позиции + коррекция TP/SL
   - Отложить: DCA и переключение режима

### Вопросы для обсуждения:

1. Согласны ли вы с параметрами увеличения позиции (5 добавлений, 60 сек, -2%)?
2. Какой минимальный размер Partial TP вам подходит ($5, $10, адаптивно)?
3. Какие автономные решения приоритетны для вас?

